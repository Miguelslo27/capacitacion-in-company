{"request":{"hurl":"http:\/\/capacitacion.local\/wp-content\/plugins\/builderpress\/assets\/libs\/isotope\/isotope.pkgd.min.js","inline":"","disable_minification":false,"type":"js","handle":"builder-press-isotope"},"log":"\/wp-content\/plugins\/builderpress\/assets\/libs\/isotope\/isotope.pkgd.min.js\r\n","code":"\/*!\n * Isotope PACKAGED v3.0.5\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * http:\/\/isotope.metafizzy.co\n * Copyright 2017 Metafizzy\n *\/\n\n\/**\n * Bridget makes jQuery widgets\n * v2.0.1\n * MIT license\n *\/\n\n\/* jshint browser: true, strict: true, undef: true, unused: true *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/*jshint strict: false *\/\n\t\/* globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('jquery-bridget\/jquery-bridget', ['jquery'], function (jQuery) {\n\t\t\treturn factory(window, jQuery);\n\t\t});\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\twindow,\n\t\t\trequire('jquery')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.jQueryBridget = factory(\n\t\t\twindow,\n\t\t\twindow.jQuery\n\t\t);\n\t}\n\n}(window, function factory(window, jQuery) {\n\t'use strict';\n\n\/\/ ----- utils ----- \/\/\n\n\tvar arraySlice = Array.prototype.slice;\n\n\/\/ helper function for logging errors\n\/\/ $.error breaks jQuery chaining\n\tvar console = window.console;\n\tvar logError = typeof console == 'undefined' ? function () {\n\t\t} :\n\t\tfunction (message) {\n\t\t\tconsole.error(message);\n\t\t};\n\n\/\/ ----- jQueryBridget ----- \/\/\n\n\tfunction jQueryBridget(namespace, PluginClass, $) {\n\t\t$ = $ || jQuery || window.jQuery;\n\t\tif (!$) {\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/ add option method -> $().plugin('option', {...})\n\t\tif (!PluginClass.prototype.option) {\n\t\t\t\/\/ option setter\n\t\t\tPluginClass.prototype.option = function (opts) {\n\t\t\t\t\/\/ bail out if not an object\n\t\t\t\tif (!$.isPlainObject(opts)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.options = $.extend(true, this.options, opts);\n\t\t\t};\n\t\t}\n\n\t\t\/\/ make jQuery plugin\n\t\t$.fn[namespace] = function (arg0 \/*, arg1 *\/) {\n\t\t\tif (typeof arg0 == 'string') {\n\t\t\t\t\/\/ method call $().plugin( 'methodName', { options } )\n\t\t\t\t\/\/ shift arguments by 1\n\t\t\t\tvar args = arraySlice.call(arguments, 1);\n\t\t\t\treturn methodCall(this, arg0, args);\n\t\t\t}\n\t\t\t\/\/ just $().plugin({ options })\n\t\t\tplainCall(this, arg0);\n\t\t\treturn this;\n\t\t};\n\n\t\t\/\/ $().plugin('methodName')\n\t\tfunction methodCall($elems, methodName, args) {\n\t\t\tvar returnValue;\n\t\t\tvar pluginMethodStr = '$().' + namespace + '(\"' + methodName + '\")';\n\n\t\t\t$elems.each(function (i, elem) {\n\t\t\t\t\/\/ get instance\n\t\t\t\tvar instance = $.data(elem, namespace);\n\t\t\t\tif (!instance) {\n\t\t\t\t\tlogError(namespace + ' not initialized. Cannot call methods, i.e. ' +\n\t\t\t\t\t\tpluginMethodStr);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar method = instance[methodName];\n\t\t\t\tif (!method || methodName.charAt(0) == '_') {\n\t\t\t\t\tlogError(pluginMethodStr + ' is not a valid method');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t\/\/ apply method, get return value\n\t\t\t\tvar value = method.apply(instance, args);\n\t\t\t\t\/\/ set return value if value is returned, use only first value\n\t\t\t\treturnValue = returnValue === undefined ? value : returnValue;\n\t\t\t});\n\n\t\t\treturn returnValue !== undefined ? returnValue : $elems;\n\t\t}\n\n\t\tfunction plainCall($elems, options) {\n\t\t\t$elems.each(function (i, elem) {\n\t\t\t\tvar instance = $.data(elem, namespace);\n\t\t\t\tif (instance) {\n\t\t\t\t\t\/\/ set options & init\n\t\t\t\t\tinstance.option(options);\n\t\t\t\t\tinstance._init();\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ initialize new instance\n\t\t\t\t\tinstance = new PluginClass(elem, options);\n\t\t\t\t\t$.data(elem, namespace, instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tupdateJQuery($);\n\n\t}\n\n\/\/ ----- updateJQuery ----- \/\/\n\n\/\/ set $.bridget for v1 backwards compatibility\n\tfunction updateJQuery($) {\n\t\tif (!$ || ($ && $.bridget)) {\n\t\t\treturn;\n\t\t}\n\t\t$.bridget = jQueryBridget;\n\t}\n\n\tupdateJQuery(jQuery || window.jQuery);\n\n\/\/ -----  ----- \/\/\n\n\treturn jQueryBridget;\n\n}));\n\n\/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n *\/\n\n\/* jshint unused: true, undef: true, strict: true *\/\n\n(function (global, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/* globals define, module, window *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD - RequireJS\n\t\tdefine('ev-emitter\/ev-emitter', factory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS - Browserify, Webpack\n\t\tmodule.exports = factory();\n\t} else {\n\t\t\/\/ Browser globals\n\t\tglobal.EvEmitter = factory();\n\t}\n\n}(typeof window != 'undefined' ? window : this, function () {\n\n\n\tfunction EvEmitter() {\n\t}\n\n\tvar proto = EvEmitter.prototype;\n\n\tproto.on = function (eventName, listener) {\n\t\tif (!eventName || !listener) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ set events hash\n\t\tvar events = this._events = this._events || {};\n\t\t\/\/ set listeners array\n\t\tvar listeners = events[eventName] = events[eventName] || [];\n\t\t\/\/ only add once\n\t\tif (listeners.indexOf(listener) == -1) {\n\t\t\tlisteners.push(listener);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tproto.once = function (eventName, listener) {\n\t\tif (!eventName || !listener) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ add event\n\t\tthis.on(eventName, listener);\n\t\t\/\/ set once flag\n\t\t\/\/ set onceEvents hash\n\t\tvar onceEvents = this._onceEvents = this._onceEvents || {};\n\t\t\/\/ set onceListeners object\n\t\tvar onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};\n\t\t\/\/ set flag\n\t\tonceListeners[listener] = true;\n\n\t\treturn this;\n\t};\n\n\tproto.off = function (eventName, listener) {\n\t\tvar listeners = this._events && this._events[eventName];\n\t\tif (!listeners || !listeners.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index != -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tproto.emitEvent = function (eventName, args) {\n\t\tvar listeners = this._events && this._events[eventName];\n\t\tif (!listeners || !listeners.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ copy over to avoid interference if .off() in listener\n\t\tlisteners = listeners.slice(0);\n\t\targs = args || [];\n\t\t\/\/ once stuff\n\t\tvar onceListeners = this._onceEvents && this._onceEvents[eventName];\n\n\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\tvar listener = listeners[i]\n\t\t\tvar isOnce = onceListeners && onceListeners[listener];\n\t\t\tif (isOnce) {\n\t\t\t\t\/\/ remove listener\n\t\t\t\t\/\/ remove before trigger to prevent recursion\n\t\t\t\tthis.off(eventName, listener);\n\t\t\t\t\/\/ unset once flag\n\t\t\t\tdelete onceListeners[listener];\n\t\t\t}\n\t\t\t\/\/ trigger listener\n\t\t\tlistener.apply(this, args);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tproto.allOff = function () {\n\t\tdelete this._events;\n\t\tdelete this._onceEvents;\n\t};\n\n\treturn EvEmitter;\n\n}));\n\n\/*!\n * getSize v2.0.2\n * measure size of elements\n * MIT license\n *\/\n\n\/*jshint browser: true, strict: true, undef: true, unused: true *\/\n\/*global define: false, module: false, console: false *\/\n\n(function (window, factory) {\n\t'use strict';\n\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('get-size\/get-size', [], function () {\n\t\t\treturn factory();\n\t\t});\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory();\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.getSize = factory();\n\t}\n\n})(window, function factory() {\n\t'use strict';\n\n\/\/ -------------------------- helpers -------------------------- \/\/\n\n\/\/ get a number from a string, not a percentage\n\tfunction getStyleSize(value) {\n\t\tvar num = parseFloat(value);\n\t\t\/\/ not a percent like '100%', and a number\n\t\tvar isValid = value.indexOf('%') == -1 && !isNaN(num);\n\t\treturn isValid && num;\n\t}\n\n\tfunction noop() {\n\t}\n\n\tvar logError = typeof console == 'undefined' ? noop :\n\t\tfunction (message) {\n\t\t\tconsole.error(message);\n\t\t};\n\n\/\/ -------------------------- measurements -------------------------- \/\/\n\n\tvar measurements = [\n\t\t'paddingLeft',\n\t\t'paddingRight',\n\t\t'paddingTop',\n\t\t'paddingBottom',\n\t\t'marginLeft',\n\t\t'marginRight',\n\t\t'marginTop',\n\t\t'marginBottom',\n\t\t'borderLeftWidth',\n\t\t'borderRightWidth',\n\t\t'borderTopWidth',\n\t\t'borderBottomWidth'\n\t];\n\n\tvar measurementsLength = measurements.length;\n\n\tfunction getZeroSize() {\n\t\tvar size = {\n\t\t\twidth      : 0,\n\t\t\theight     : 0,\n\t\t\tinnerWidth : 0,\n\t\t\tinnerHeight: 0,\n\t\t\touterWidth : 0,\n\t\t\touterHeight: 0\n\t\t};\n\t\tfor (var i = 0; i < measurementsLength; i++) {\n\t\t\tvar measurement = measurements[i];\n\t\t\tsize[measurement] = 0;\n\t\t}\n\t\treturn size;\n\t}\n\n\/\/ -------------------------- getStyle -------------------------- \/\/\n\n\t\/**\n\t * getStyle, get style of element, check for Firefox bug\n\t * http:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=548397\n\t *\/\n\tfunction getStyle(elem) {\n\t\tvar style = getComputedStyle(elem);\n\t\tif (!style) {\n\t\t\tlogError('Style returned ' + style +\n\t\t\t\t'. Are you running this code in a hidden iframe on Firefox? ' +\n\t\t\t\t'See http:\/\/bit.ly\/getsizebug1');\n\t\t}\n\t\treturn style;\n\t}\n\n\/\/ -------------------------- setup -------------------------- \/\/\n\n\tvar isSetup = false;\n\n\tvar isBoxSizeOuter;\n\n\t\/**\n\t * setup\n\t * check isBoxSizerOuter\n\t * do on first getSize() rather than on page load for Firefox bug\n\t *\/\n\tfunction setup() {\n\t\t\/\/ setup once\n\t\tif (isSetup) {\n\t\t\treturn;\n\t\t}\n\t\tisSetup = true;\n\n\t\t\/\/ -------------------------- box sizing -------------------------- \/\/\n\n\t\t\/**\n\t\t * WebKit measures the outer-width on style.width on border-box elems\n\t\t * IE & Firefox<29 measures the inner-width\n\t\t *\/\n\t\tvar div = document.createElement('div');\n\t\tdiv.style.width = '200px';\n\t\tdiv.style.padding = '1px 2px 3px 4px';\n\t\tdiv.style.borderStyle = 'solid';\n\t\tdiv.style.borderWidth = '1px 2px 3px 4px';\n\t\tdiv.style.boxSizing = 'border-box';\n\n\t\tvar body = document.body || document.documentElement;\n\t\tbody.appendChild(div);\n\t\tvar style = getStyle(div);\n\n\t\tgetSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;\n\t\tbody.removeChild(div);\n\n\t}\n\n\/\/ -------------------------- getSize -------------------------- \/\/\n\n\tfunction getSize(elem) {\n\t\tsetup();\n\n\t\t\/\/ use querySeletor if elem is string\n\t\tif (typeof elem == 'string') {\n\t\t\telem = document.querySelector(elem);\n\t\t}\n\n\t\t\/\/ do not proceed on non-objects\n\t\tif (!elem || typeof elem != 'object' || !elem.nodeType) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar style = getStyle(elem);\n\n\t\t\/\/ if hidden, everything is 0\n\t\tif (style.display == 'none') {\n\t\t\treturn getZeroSize();\n\t\t}\n\n\t\tvar size = {};\n\t\tsize.width = elem.offsetWidth;\n\t\tsize.height = elem.offsetHeight;\n\n\t\tvar isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n\t\t\/\/ get all measurements\n\t\tfor (var i = 0; i < measurementsLength; i++) {\n\t\t\tvar measurement = measurements[i];\n\t\t\tvar value = style[measurement];\n\t\t\tvar num = parseFloat(value);\n\t\t\t\/\/ any 'auto', 'medium' value will be 0\n\t\t\tsize[measurement] = !isNaN(num) ? num : 0;\n\t\t}\n\n\t\tvar paddingWidth = size.paddingLeft + size.paddingRight;\n\t\tvar paddingHeight = size.paddingTop + size.paddingBottom;\n\t\tvar marginWidth = size.marginLeft + size.marginRight;\n\t\tvar marginHeight = size.marginTop + size.marginBottom;\n\t\tvar borderWidth = size.borderLeftWidth + size.borderRightWidth;\n\t\tvar borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n\t\tvar isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n\t\t\/\/ overwrite width and height if we can get it from style\n\t\tvar styleWidth = getStyleSize(style.width);\n\t\tif (styleWidth !== false) {\n\t\t\tsize.width = styleWidth +\n\t\t\t\t\/\/ add padding and border unless it's already including it\n\t\t\t\t(isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);\n\t\t}\n\n\t\tvar styleHeight = getStyleSize(style.height);\n\t\tif (styleHeight !== false) {\n\t\t\tsize.height = styleHeight +\n\t\t\t\t\/\/ add padding and border unless it's already including it\n\t\t\t\t(isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);\n\t\t}\n\n\t\tsize.innerWidth = size.width - (paddingWidth + borderWidth);\n\t\tsize.innerHeight = size.height - (paddingHeight + borderHeight);\n\n\t\tsize.outerWidth = size.width + marginWidth;\n\t\tsize.outerHeight = size.height + marginHeight;\n\n\t\treturn size;\n\t}\n\n\treturn getSize;\n\n});\n\n\/**\n * matchesSelector v2.0.2\n * matchesSelector( element, '.selector' )\n * MIT license\n *\/\n\n\/*jshint browser: true, strict: true, undef: true, unused: true *\/\n\n(function (window, factory) {\n\t\/*global define: false, module: false *\/\n\t'use strict';\n\t\/\/ universal module definition\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('desandro-matches-selector\/matches-selector', factory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory();\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.matchesSelector = factory();\n\t}\n\n}(window, function factory() {\n\t'use strict';\n\n\tvar matchesMethod = (function () {\n\t\tvar ElemProto = window.Element.prototype;\n\t\t\/\/ check for the standard method name first\n\t\tif (ElemProto.matches) {\n\t\t\treturn 'matches';\n\t\t}\n\t\t\/\/ check un-prefixed\n\t\tif (ElemProto.matchesSelector) {\n\t\t\treturn 'matchesSelector';\n\t\t}\n\t\t\/\/ check vendor prefixes\n\t\tvar prefixes = ['webkit', 'moz', 'ms', 'o'];\n\n\t\tfor (var i = 0; i < prefixes.length; i++) {\n\t\t\tvar prefix = prefixes[i];\n\t\t\tvar method = prefix + 'MatchesSelector';\n\t\t\tif (ElemProto[method]) {\n\t\t\t\treturn method;\n\t\t\t}\n\t\t}\n\t})();\n\n\treturn function matchesSelector(elem, selector) {\n\t\treturn elem[matchesMethod](selector);\n\t};\n\n}));\n\n\/**\n * Fizzy UI utils v2.0.5\n * MIT license\n *\/\n\n\/*jshint browser: true, undef: true, unused: true, strict: true *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/*jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('fizzy-ui-utils\/utils', [\n\t\t\t'desandro-matches-selector\/matches-selector'\n\t\t], function (matchesSelector) {\n\t\t\treturn factory(window, matchesSelector);\n\t\t});\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\twindow,\n\t\t\trequire('desandro-matches-selector')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.fizzyUIUtils = factory(\n\t\t\twindow,\n\t\t\twindow.matchesSelector\n\t\t);\n\t}\n\n}(window, function factory(window, matchesSelector) {\n\n\n\tvar utils = {};\n\n\/\/ ----- extend ----- \/\/\n\n\/\/ extends objects\n\tutils.extend = function (a, b) {\n\t\tfor (var prop in b) {\n\t\t\ta[prop] = b[prop];\n\t\t}\n\t\treturn a;\n\t};\n\n\/\/ ----- modulo ----- \/\/\n\n\tutils.modulo = function (num, div) {\n\t\treturn ((num % div) + div) % div;\n\t};\n\n\/\/ ----- makeArray ----- \/\/\n\n\/\/ turn element or nodeList into an array\n\tutils.makeArray = function (obj) {\n\t\tvar ary = [];\n\t\tif (Array.isArray(obj)) {\n\t\t\t\/\/ use object if already an array\n\t\t\tary = obj;\n\t\t} else if (obj && typeof obj == 'object' &&\n\t\t\ttypeof obj.length == 'number') {\n\t\t\t\/\/ convert nodeList to array\n\t\t\tfor (var i = 0; i < obj.length; i++) {\n\t\t\t\tary.push(obj[i]);\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/ array of single index\n\t\t\tary.push(obj);\n\t\t}\n\t\treturn ary;\n\t};\n\n\/\/ ----- removeFrom ----- \/\/\n\n\tutils.removeFrom = function (ary, obj) {\n\t\tvar index = ary.indexOf(obj);\n\t\tif (index != -1) {\n\t\t\tary.splice(index, 1);\n\t\t}\n\t};\n\n\/\/ ----- getParent ----- \/\/\n\n\tutils.getParent = function (elem, selector) {\n\t\twhile (elem.parentNode && elem != document.body) {\n\t\t\telem = elem.parentNode;\n\t\t\tif (matchesSelector(elem, selector)) {\n\t\t\t\treturn elem;\n\t\t\t}\n\t\t}\n\t};\n\n\/\/ ----- getQueryElement ----- \/\/\n\n\/\/ use element as selector string\n\tutils.getQueryElement = function (elem) {\n\t\tif (typeof elem == 'string') {\n\t\t\treturn document.querySelector(elem);\n\t\t}\n\t\treturn elem;\n\t};\n\n\/\/ ----- handleEvent ----- \/\/\n\n\/\/ enable .ontype to trigger from .addEventListener( elem, 'type' )\n\tutils.handleEvent = function (event) {\n\t\tvar method = 'on' + event.type;\n\t\tif (this[method]) {\n\t\t\tthis[method](event);\n\t\t}\n\t};\n\n\/\/ ----- filterFindElements ----- \/\/\n\n\tutils.filterFindElements = function (elems, selector) {\n\t\t\/\/ make array of elems\n\t\telems = utils.makeArray(elems);\n\t\tvar ffElems = [];\n\n\t\telems.forEach(function (elem) {\n\t\t\t\/\/ check that elem is an actual element\n\t\t\tif (!(elem instanceof HTMLElement)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ add elem if no selector\n\t\t\tif (!selector) {\n\t\t\t\tffElems.push(elem);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ filter & find items if we have a selector\n\t\t\t\/\/ filter\n\t\t\tif (matchesSelector(elem, selector)) {\n\t\t\t\tffElems.push(elem);\n\t\t\t}\n\t\t\t\/\/ find children\n\t\t\tvar childElems = elem.querySelectorAll(selector);\n\t\t\t\/\/ concat childElems to filterFound array\n\t\t\tfor (var i = 0; i < childElems.length; i++) {\n\t\t\t\tffElems.push(childElems[i]);\n\t\t\t}\n\t\t});\n\n\t\treturn ffElems;\n\t};\n\n\/\/ ----- debounceMethod ----- \/\/\n\n\tutils.debounceMethod = function (_class, methodName, threshold) {\n\t\t\/\/ original method\n\t\tvar method = _class.prototype[methodName];\n\t\tvar timeoutName = methodName + 'Timeout';\n\n\t\t_class.prototype[methodName] = function () {\n\t\t\tvar timeout = this[timeoutName];\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\t\t\tvar args = arguments;\n\n\t\t\tvar _this = this;\n\t\t\tthis[timeoutName] = setTimeout(function () {\n\t\t\t\tmethod.apply(_this, args);\n\t\t\t\tdelete _this[timeoutName];\n\t\t\t}, threshold || 100);\n\t\t};\n\t};\n\n\/\/ ----- docReady ----- \/\/\n\n\tutils.docReady = function (callback) {\n\t\tvar readyState = document.readyState;\n\t\tif (readyState == 'complete' || readyState == 'interactive') {\n\t\t\t\/\/ do async to allow for other scripts to run. metafizzy\/flickity#441\n\t\t\tsetTimeout(callback);\n\t\t} else {\n\t\t\tdocument.addEventListener('DOMContentLoaded', callback);\n\t\t}\n\t};\n\n\/\/ ----- htmlInit ----- \/\/\n\n\/\/ http:\/\/jamesroberts.name\/blog\/2010\/02\/22\/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore\/\n\tutils.toDashed = function (str) {\n\t\treturn str.replace(\/(.)([A-Z])\/g, function (match, $1, $2) {\n\t\t\treturn $1 + '-' + $2;\n\t\t}).toLowerCase();\n\t};\n\n\tvar console = window.console;\n\t\/**\n\t * allow user to initialize classes via [data-namespace] or .js-namespace class\n\t * htmlInit( Widget, 'widgetName' )\n\t * options are parsed from data-namespace-options\n\t *\/\n\tutils.htmlInit = function (WidgetClass, namespace) {\n\t\tutils.docReady(function () {\n\t\t\tvar dashedNamespace = utils.toDashed(namespace);\n\t\t\tvar dataAttr = 'data-' + dashedNamespace;\n\t\t\tvar dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');\n\t\t\tvar jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);\n\t\t\tvar elems = utils.makeArray(dataAttrElems)\n\t\t\t\t.concat(utils.makeArray(jsDashElems));\n\t\t\tvar dataOptionsAttr = dataAttr + '-options';\n\t\t\tvar jQuery = window.jQuery;\n\n\t\t\telems.forEach(function (elem) {\n\t\t\t\tvar attr = elem.getAttribute(dataAttr) ||\n\t\t\t\t\telem.getAttribute(dataOptionsAttr);\n\t\t\t\tvar options;\n\t\t\t\ttry {\n\t\t\t\t\toptions = attr && JSON.parse(attr);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t\/\/ log error, do not initialize\n\t\t\t\t\tif (console) {\n\t\t\t\t\t\tconsole.error('Error parsing ' + dataAttr + ' on ' + elem.className +\n\t\t\t\t\t\t\t': ' + error);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\/\/ initialize\n\t\t\t\tvar instance = new WidgetClass(elem, options);\n\t\t\t\t\/\/ make available via $().data('namespace')\n\t\t\t\tif (jQuery) {\n\t\t\t\t\tjQuery.data(elem, namespace, instance);\n\t\t\t\t}\n\t\t\t});\n\n\t\t});\n\t};\n\n\/\/ -----  ----- \/\/\n\n\treturn utils;\n\n}));\n\n\/**\n * Outlayer Item\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/* globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD - RequireJS\n\t\tdefine('outlayer\/item', [\n\t\t\t\t'ev-emitter\/ev-emitter',\n\t\t\t\t'get-size\/get-size'\n\t\t\t],\n\t\t\tfactory\n\t\t);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS - Browserify, Webpack\n\t\tmodule.exports = factory(\n\t\t\trequire('ev-emitter'),\n\t\t\trequire('get-size')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Outlayer = {};\n\t\twindow.Outlayer.Item = factory(\n\t\t\twindow.EvEmitter,\n\t\t\twindow.getSize\n\t\t);\n\t}\n\n}(window, function factory(EvEmitter, getSize) {\n\t'use strict';\n\n\/\/ ----- helpers ----- \/\/\n\n\tfunction isEmptyObj(obj) {\n\t\tfor (var prop in obj) {\n\t\t\treturn false;\n\t\t}\n\t\tprop = null;\n\t\treturn true;\n\t}\n\n\/\/ -------------------------- CSS3 support -------------------------- \/\/\n\n\n\tvar docElemStyle = document.documentElement.style;\n\n\tvar transitionProperty = typeof docElemStyle.transition == 'string' ?\n\t\t'transition' : 'WebkitTransition';\n\tvar transformProperty = typeof docElemStyle.transform == 'string' ?\n\t\t'transform' : 'WebkitTransform';\n\n\tvar transitionEndEvent = {\n\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\ttransition      : 'transitionend'\n\t}[transitionProperty];\n\n\/\/ cache all vendor properties that could have vendor prefix\n\tvar vendorProperties = {\n\t\ttransform         : transformProperty,\n\t\ttransition        : transitionProperty,\n\t\ttransitionDuration: transitionProperty + 'Duration',\n\t\ttransitionProperty: transitionProperty + 'Property',\n\t\ttransitionDelay   : transitionProperty + 'Delay'\n\t};\n\n\/\/ -------------------------- Item -------------------------- \/\/\n\n\tfunction Item(element, layout) {\n\t\tif (!element) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.element = element;\n\t\t\/\/ parent layout class, i.e. Masonry, Isotope, or Packery\n\t\tthis.layout = layout;\n\t\tthis.position = {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\n\t\tthis._create();\n\t}\n\n\/\/ inherit EvEmitter\n\tvar proto = Item.prototype = Object.create(EvEmitter.prototype);\n\tproto.constructor = Item;\n\n\tproto._create = function () {\n\t\t\/\/ transition objects\n\t\tthis._transn = {\n\t\t\tingProperties: {},\n\t\t\tclean        : {},\n\t\t\tonEnd        : {}\n\t\t};\n\n\t\tthis.css({\n\t\t\tposition: 'absolute'\n\t\t});\n\t};\n\n\/\/ trigger specified handler for event type\n\tproto.handleEvent = function (event) {\n\t\tvar method = 'on' + event.type;\n\t\tif (this[method]) {\n\t\t\tthis[method](event);\n\t\t}\n\t};\n\n\tproto.getSize = function () {\n\t\tthis.size = getSize(this.element);\n\t};\n\n\t\/**\n\t * apply CSS styles to element\n\t * @param {Object} style\n\t *\/\n\tproto.css = function (style) {\n\t\tvar elemStyle = this.element.style;\n\n\t\tfor (var prop in style) {\n\t\t\t\/\/ use vendor property if available\n\t\t\tvar supportedProp = vendorProperties[prop] || prop;\n\t\t\telemStyle[supportedProp] = style[prop];\n\t\t}\n\t};\n\n\t\/\/ measure position, and sets it\n\tproto.getPosition = function () {\n\t\tvar style = getComputedStyle(this.element);\n\t\tvar isOriginLeft = this.layout._getOption('originLeft');\n\t\tvar isOriginTop = this.layout._getOption('originTop');\n\t\tvar xValue = style[isOriginLeft ? 'left' : 'right'];\n\t\tvar yValue = style[isOriginTop ? 'top' : 'bottom'];\n\t\t\/\/ convert percent to pixels\n\t\tvar layoutSize = this.layout.size;\n\t\tvar x = xValue.indexOf('%') != -1 ?\n\t\t\t(parseFloat(xValue) \/ 100) * layoutSize.width : parseInt(xValue, 10);\n\t\tvar y = yValue.indexOf('%') != -1 ?\n\t\t\t(parseFloat(yValue) \/ 100) * layoutSize.height : parseInt(yValue, 10);\n\n\t\t\/\/ clean up 'auto' or other non-integer values\n\t\tx = isNaN(x) ? 0 : x;\n\t\ty = isNaN(y) ? 0 : y;\n\t\t\/\/ remove padding from measurement\n\t\tx -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n\t\ty -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n\n\t\tthis.position.x = x;\n\t\tthis.position.y = y;\n\t};\n\n\/\/ set settled position, apply padding\n\tproto.layoutPosition = function () {\n\t\tvar layoutSize = this.layout.size;\n\t\tvar style = {};\n\t\tvar isOriginLeft = this.layout._getOption('originLeft');\n\t\tvar isOriginTop = this.layout._getOption('originTop');\n\n\t\t\/\/ x\n\t\tvar xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';\n\t\tvar xProperty = isOriginLeft ? 'left' : 'right';\n\t\tvar xResetProperty = isOriginLeft ? 'right' : 'left';\n\n\t\tvar x = this.position.x + layoutSize[xPadding];\n\t\t\/\/ set in percentage or pixels\n\t\tstyle[xProperty] = this.getXValue(x);\n\t\t\/\/ reset other property\n\t\tstyle[xResetProperty] = '';\n\n\t\t\/\/ y\n\t\tvar yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';\n\t\tvar yProperty = isOriginTop ? 'top' : 'bottom';\n\t\tvar yResetProperty = isOriginTop ? 'bottom' : 'top';\n\n\t\tvar y = this.position.y + layoutSize[yPadding];\n\t\t\/\/ set in percentage or pixels\n\t\tstyle[yProperty] = this.getYValue(y);\n\t\t\/\/ reset other property\n\t\tstyle[yResetProperty] = '';\n\n\t\tthis.css(style);\n\t\tthis.emitEvent('layout', [this]);\n\t};\n\n\tproto.getXValue = function (x) {\n\t\tvar isHorizontal = this.layout._getOption('horizontal');\n\t\treturn this.layout.options.percentPosition && !isHorizontal ?\n\t\t\t((x \/ this.layout.size.width) * 100) + '%' : x + 'px';\n\t};\n\n\tproto.getYValue = function (y) {\n\t\tvar isHorizontal = this.layout._getOption('horizontal');\n\t\treturn this.layout.options.percentPosition && isHorizontal ?\n\t\t\t((y \/ this.layout.size.height) * 100) + '%' : y + 'px';\n\t};\n\n\tproto._transitionTo = function (x, y) {\n\t\tthis.getPosition();\n\t\t\/\/ get current x & y from top\/left\n\t\tvar curX = this.position.x;\n\t\tvar curY = this.position.y;\n\n\t\tvar compareX = parseInt(x, 10);\n\t\tvar compareY = parseInt(y, 10);\n\t\tvar didNotMove = compareX === this.position.x && compareY === this.position.y;\n\n\t\t\/\/ save end position\n\t\tthis.setPosition(x, y);\n\n\t\t\/\/ if did not move and not transitioning, just go to layout\n\t\tif (didNotMove && !this.isTransitioning) {\n\t\t\tthis.layoutPosition();\n\t\t\treturn;\n\t\t}\n\n\t\tvar transX = x - curX;\n\t\tvar transY = y - curY;\n\t\tvar transitionStyle = {};\n\t\ttransitionStyle.transform = this.getTranslate(transX, transY);\n\n\t\tthis.transition({\n\t\t\tto             : transitionStyle,\n\t\t\tonTransitionEnd: {\n\t\t\t\ttransform: this.layoutPosition\n\t\t\t},\n\t\t\tisCleaning     : true\n\t\t});\n\t};\n\n\tproto.getTranslate = function (x, y) {\n\t\t\/\/ flip cooridinates if origin on right or bottom\n\t\tvar isOriginLeft = this.layout._getOption('originLeft');\n\t\tvar isOriginTop = this.layout._getOption('originTop');\n\t\tx = isOriginLeft ? x : -x;\n\t\ty = isOriginTop ? y : -y;\n\t\treturn 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n\t};\n\n\/\/ non transition + transform support\n\tproto.goTo = function (x, y) {\n\t\tthis.setPosition(x, y);\n\t\tthis.layoutPosition();\n\t};\n\n\tproto.moveTo = proto._transitionTo;\n\n\tproto.setPosition = function (x, y) {\n\t\tthis.position.x = parseInt(x, 10);\n\t\tthis.position.y = parseInt(y, 10);\n\t};\n\n\/\/ ----- transition ----- \/\/\n\n\t\/**\n\t * @param {Object} style - CSS\n\t * @param {Function} onTransitionEnd\n\t *\/\n\n\/\/ non transition, just trigger callback\n\tproto._nonTransition = function (args) {\n\t\tthis.css(args.to);\n\t\tif (args.isCleaning) {\n\t\t\tthis._removeStyles(args.to);\n\t\t}\n\t\tfor (var prop in args.onTransitionEnd) {\n\t\t\targs.onTransitionEnd[prop].call(this);\n\t\t}\n\t};\n\n\t\/**\n\t * proper transition\n\t * @param {Object} args - arguments\n\t *   @param {Object} to - style to transition to\n\t *   @param {Object} from - style to start transition from\n\t *   @param {Boolean} isCleaning - removes transition styles after transition\n\t *   @param {Function} onTransitionEnd - callback\n\t *\/\n\tproto.transition = function (args) {\n\t\t\/\/ redirect to nonTransition if no transition duration\n\t\tif (!parseFloat(this.layout.options.transitionDuration)) {\n\t\t\tthis._nonTransition(args);\n\t\t\treturn;\n\t\t}\n\n\t\tvar _transition = this._transn;\n\t\t\/\/ keep track of onTransitionEnd callback by css property\n\t\tfor (var prop in args.onTransitionEnd) {\n\t\t\t_transition.onEnd[prop] = args.onTransitionEnd[prop];\n\t\t}\n\t\t\/\/ keep track of properties that are transitioning\n\t\tfor (prop in args.to) {\n\t\t\t_transition.ingProperties[prop] = true;\n\t\t\t\/\/ keep track of properties to clean up when transition is done\n\t\t\tif (args.isCleaning) {\n\t\t\t\t_transition.clean[prop] = true;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ set from styles\n\t\tif (args.from) {\n\t\t\tthis.css(args.from);\n\t\t\t\/\/ force redraw. http:\/\/blog.alexmaccaw.com\/css-transitions\n\t\t\tvar h = this.element.offsetHeight;\n\t\t\t\/\/ hack for JSHint to hush about unused var\n\t\t\th = null;\n\t\t}\n\t\t\/\/ enable transition\n\t\tthis.enableTransition(args.to);\n\t\t\/\/ set styles that are transitioning\n\t\tthis.css(args.to);\n\n\t\tthis.isTransitioning = true;\n\n\t};\n\n\/\/ dash before all cap letters, including first for\n\/\/ WebkitTransform => -webkit-transform\n\tfunction toDashedAll(str) {\n\t\treturn str.replace(\/([A-Z])\/g, function ($1) {\n\t\t\treturn '-' + $1.toLowerCase();\n\t\t});\n\t}\n\n\tvar transitionProps = 'opacity,' + toDashedAll(transformProperty);\n\n\tproto.enableTransition = function (\/* style *\/) {\n\t\t\/\/ HACK changing transitionProperty during a transition\n\t\t\/\/ will cause transition to jump\n\t\tif (this.isTransitioning) {\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/ make `transition: foo, bar, baz` from style object\n\t\t\/\/ HACK un-comment this when enableTransition can work\n\t\t\/\/ while a transition is happening\n\t\t\/\/ var transitionValues = [];\n\t\t\/\/ for ( var prop in style ) {\n\t\t\/\/   \/\/ dash-ify camelCased properties like WebkitTransition\n\t\t\/\/   prop = vendorProperties[ prop ] || prop;\n\t\t\/\/   transitionValues.push( toDashedAll( prop ) );\n\t\t\/\/ }\n\t\t\/\/ munge number to millisecond, to match stagger\n\t\tvar duration = this.layout.options.transitionDuration;\n\t\tduration = typeof duration == 'number' ? duration + 'ms' : duration;\n\t\t\/\/ enable transition styles\n\t\tthis.css({\n\t\t\ttransitionProperty: transitionProps,\n\t\t\ttransitionDuration: duration,\n\t\t\ttransitionDelay   : this.staggerDelay || 0\n\t\t});\n\t\t\/\/ listen for transition end event\n\t\tthis.element.addEventListener(transitionEndEvent, this, false);\n\t};\n\n\/\/ ----- events ----- \/\/\n\n\tproto.onwebkitTransitionEnd = function (event) {\n\t\tthis.ontransitionend(event);\n\t};\n\n\tproto.onotransitionend = function (event) {\n\t\tthis.ontransitionend(event);\n\t};\n\n\/\/ properties that I munge to make my life easier\n\tvar dashedVendorProperties = {\n\t\t'-webkit-transform': 'transform'\n\t};\n\n\tproto.ontransitionend = function (event) {\n\t\t\/\/ disregard bubbled events from children\n\t\tif (event.target !== this.element) {\n\t\t\treturn;\n\t\t}\n\t\tvar _transition = this._transn;\n\t\t\/\/ get property name of transitioned property, convert to prefix-free\n\t\tvar propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;\n\n\t\t\/\/ remove property that has completed transitioning\n\t\tdelete _transition.ingProperties[propertyName];\n\t\t\/\/ check if any properties are still transitioning\n\t\tif (isEmptyObj(_transition.ingProperties)) {\n\t\t\t\/\/ all properties have completed transitioning\n\t\t\tthis.disableTransition();\n\t\t}\n\t\t\/\/ clean style\n\t\tif (propertyName in _transition.clean) {\n\t\t\t\/\/ clean up style\n\t\t\tthis.element.style[event.propertyName] = '';\n\t\t\tdelete _transition.clean[propertyName];\n\t\t}\n\t\t\/\/ trigger onTransitionEnd callback\n\t\tif (propertyName in _transition.onEnd) {\n\t\t\tvar onTransitionEnd = _transition.onEnd[propertyName];\n\t\t\tonTransitionEnd.call(this);\n\t\t\tdelete _transition.onEnd[propertyName];\n\t\t}\n\n\t\tthis.emitEvent('transitionEnd', [this]);\n\t};\n\n\tproto.disableTransition = function () {\n\t\tthis.removeTransitionStyles();\n\t\tthis.element.removeEventListener(transitionEndEvent, this, false);\n\t\tthis.isTransitioning = false;\n\t};\n\n\t\/**\n\t * removes style property from element\n\t * @param {Object} style\n\t **\/\n\tproto._removeStyles = function (style) {\n\t\t\/\/ clean up transition styles\n\t\tvar cleanStyle = {};\n\t\tfor (var prop in style) {\n\t\t\tcleanStyle[prop] = '';\n\t\t}\n\t\tthis.css(cleanStyle);\n\t};\n\n\tvar cleanTransitionStyle = {\n\t\ttransitionProperty: '',\n\t\ttransitionDuration: '',\n\t\ttransitionDelay   : ''\n\t};\n\n\tproto.removeTransitionStyles = function () {\n\t\t\/\/ remove transition\n\t\tthis.css(cleanTransitionStyle);\n\t};\n\n\/\/ ----- stagger ----- \/\/\n\n\tproto.stagger = function (delay) {\n\t\tdelay = isNaN(delay) ? 0 : delay;\n\t\tthis.staggerDelay = delay + 'ms';\n\t};\n\n\/\/ ----- show\/hide\/remove ----- \/\/\n\n\/\/ remove element from DOM\n\tproto.removeElem = function () {\n\t\tthis.element.parentNode.removeChild(this.element);\n\t\t\/\/ remove display: none\n\t\tthis.css({display: ''});\n\t\tthis.emitEvent('remove', [this]);\n\t};\n\n\tproto.remove = function () {\n\t\t\/\/ just remove element if no transition support or no transition\n\t\tif (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n\t\t\tthis.removeElem();\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/ start transition\n\t\tthis.once('transitionEnd', function () {\n\t\t\tthis.removeElem();\n\t\t});\n\t\tthis.hide();\n\t};\n\n\tproto.reveal = function () {\n\t\tdelete this.isHidden;\n\t\t\/\/ remove display: none\n\t\tthis.css({display: ''});\n\n\t\tvar options = this.layout.options;\n\n\t\tvar onTransitionEnd = {};\n\t\tvar transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');\n\t\tonTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n\n\t\tthis.transition({\n\t\t\tfrom           : options.hiddenStyle,\n\t\t\tto             : options.visibleStyle,\n\t\t\tisCleaning     : true,\n\t\t\tonTransitionEnd: onTransitionEnd\n\t\t});\n\t};\n\n\tproto.onRevealTransitionEnd = function () {\n\t\t\/\/ check if still visible\n\t\t\/\/ during transition, item may have been hidden\n\t\tif (!this.isHidden) {\n\t\t\tthis.emitEvent('reveal');\n\t\t}\n\t};\n\n\t\/**\n\t * get style property use for hide\/reveal transition end\n\t * @param {String} styleProperty - hiddenStyle\/visibleStyle\n\t * @returns {String}\n\t *\/\n\tproto.getHideRevealTransitionEndProperty = function (styleProperty) {\n\t\tvar optionStyle = this.layout.options[styleProperty];\n\t\t\/\/ use opacity\n\t\tif (optionStyle.opacity) {\n\t\t\treturn 'opacity';\n\t\t}\n\t\t\/\/ get first property\n\t\tfor (var prop in optionStyle) {\n\t\t\treturn prop;\n\t\t}\n\t};\n\n\tproto.hide = function () {\n\t\t\/\/ set flag\n\t\tthis.isHidden = true;\n\t\t\/\/ remove display: none\n\t\tthis.css({display: ''});\n\n\t\tvar options = this.layout.options;\n\n\t\tvar onTransitionEnd = {};\n\t\tvar transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');\n\t\tonTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n\n\t\tthis.transition({\n\t\t\tfrom           : options.visibleStyle,\n\t\t\tto             : options.hiddenStyle,\n\t\t\t\/\/ keep hidden stuff hidden\n\t\t\tisCleaning     : true,\n\t\t\tonTransitionEnd: onTransitionEnd\n\t\t});\n\t};\n\n\tproto.onHideTransitionEnd = function () {\n\t\t\/\/ check if still hidden\n\t\t\/\/ during transition, item may have been un-hidden\n\t\tif (this.isHidden) {\n\t\t\tthis.css({display: 'none'});\n\t\t\tthis.emitEvent('hide');\n\t\t}\n\t};\n\n\tproto.destroy = function () {\n\t\tthis.css({\n\t\t\tposition  : '',\n\t\t\tleft      : '',\n\t\t\tright     : '',\n\t\t\ttop       : '',\n\t\t\tbottom    : '',\n\t\t\ttransition: '',\n\t\t\ttransform : ''\n\t\t});\n\t};\n\n\treturn Item;\n\n}));\n\n\/*!\n * Outlayer v2.1.0\n * the brains and guts of a layout library\n * MIT license\n *\/\n\n(function (window, factory) {\n\t'use strict';\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/* globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD - RequireJS\n\t\tdefine('outlayer\/outlayer', [\n\t\t\t\t'ev-emitter\/ev-emitter',\n\t\t\t\t'get-size\/get-size',\n\t\t\t\t'fizzy-ui-utils\/utils',\n\t\t\t\t'.\/item'\n\t\t\t],\n\t\t\tfunction (EvEmitter, getSize, utils, Item) {\n\t\t\t\treturn factory(window, EvEmitter, getSize, utils, Item);\n\t\t\t}\n\t\t);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS - Browserify, Webpack\n\t\tmodule.exports = factory(\n\t\t\twindow,\n\t\t\trequire('ev-emitter'),\n\t\t\trequire('get-size'),\n\t\t\trequire('fizzy-ui-utils'),\n\t\t\trequire('.\/item')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Outlayer = factory(\n\t\t\twindow,\n\t\t\twindow.EvEmitter,\n\t\t\twindow.getSize,\n\t\t\twindow.fizzyUIUtils,\n\t\t\twindow.Outlayer.Item\n\t\t);\n\t}\n\n}(window, function factory(window, EvEmitter, getSize, utils, Item) {\n\t'use strict';\n\n\/\/ ----- vars ----- \/\/\n\n\tvar console = window.console;\n\tvar jQuery = window.jQuery;\n\tvar noop = function () {\n\t};\n\n\/\/ -------------------------- Outlayer -------------------------- \/\/\n\n\/\/ globally unique identifiers\n\tvar GUID = 0;\n\/\/ internal store of all Outlayer intances\n\tvar instances = {};\n\n\n\t\/**\n\t * @param {Element, String} element\n\t * @param {Object} options\n\t * @constructor\n\t *\/\n\tfunction Outlayer(element, options) {\n\t\tvar queryElement = utils.getQueryElement(element);\n\t\tif (!queryElement) {\n\t\t\tif (console) {\n\t\t\t\tconsole.error('Bad element for ' + this.constructor.namespace +\n\t\t\t\t\t': ' + (queryElement || element));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.element = queryElement;\n\t\t\/\/ add jQuery\n\t\tif (jQuery) {\n\t\t\tthis.$element = jQuery(this.element);\n\t\t}\n\n\t\t\/\/ options\n\t\tthis.options = utils.extend({}, this.constructor.defaults);\n\t\tthis.option(options);\n\n\t\t\/\/ add id for Outlayer.getFromElement\n\t\tvar id = ++GUID;\n\t\tthis.element.outlayerGUID = id; \/\/ expando\n\t\tinstances[id] = this; \/\/ associate via id\n\n\t\t\/\/ kick it off\n\t\tthis._create();\n\n\t\tvar isInitLayout = this._getOption('initLayout');\n\t\tif (isInitLayout) {\n\t\t\tthis.layout();\n\t\t}\n\t}\n\n\/\/ settings are for internal use only\n\tOutlayer.namespace = 'outlayer';\n\tOutlayer.Item = Item;\n\n\/\/ default options\n\tOutlayer.defaults = {\n\t\tcontainerStyle    : {\n\t\t\tposition: 'relative'\n\t\t},\n\t\tinitLayout        : true,\n\t\toriginLeft        : true,\n\t\toriginTop         : true,\n\t\tresize            : true,\n\t\tresizeContainer   : true,\n\t\t\/\/ item options\n\t\ttransitionDuration: '0.4s',\n\t\thiddenStyle       : {\n\t\t\topacity  : 0,\n\t\t\ttransform: 'scale(0.001)'\n\t\t},\n\t\tvisibleStyle      : {\n\t\t\topacity  : 1,\n\t\t\ttransform: 'scale(1)'\n\t\t}\n\t};\n\n\tvar proto = Outlayer.prototype;\n\/\/ inherit EvEmitter\n\tutils.extend(proto, EvEmitter.prototype);\n\n\t\/**\n\t * set options\n\t * @param {Object} opts\n\t *\/\n\tproto.option = function (opts) {\n\t\tutils.extend(this.options, opts);\n\t};\n\n\t\/**\n\t * get backwards compatible option value, check old name\n\t *\/\n\tproto._getOption = function (option) {\n\t\tvar oldOption = this.constructor.compatOptions[option];\n\t\treturn oldOption && this.options[oldOption] !== undefined ?\n\t\t\tthis.options[oldOption] : this.options[option];\n\t};\n\n\tOutlayer.compatOptions = {\n\t\t\/\/ currentName: oldName\n\t\tinitLayout     : 'isInitLayout',\n\t\thorizontal     : 'isHorizontal',\n\t\tlayoutInstant  : 'isLayoutInstant',\n\t\toriginLeft     : 'isOriginLeft',\n\t\toriginTop      : 'isOriginTop',\n\t\tresize         : 'isResizeBound',\n\t\tresizeContainer: 'isResizingContainer'\n\t};\n\n\tproto._create = function () {\n\t\t\/\/ get items from children\n\t\tthis.reloadItems();\n\t\t\/\/ elements that affect layout, but are not laid out\n\t\tthis.stamps = [];\n\t\tthis.stamp(this.options.stamp);\n\t\t\/\/ set container style\n\t\tutils.extend(this.element.style, this.options.containerStyle);\n\n\t\t\/\/ bind resize method\n\t\tvar canBindResize = this._getOption('resize');\n\t\tif (canBindResize) {\n\t\t\tthis.bindResize();\n\t\t}\n\t};\n\n\/\/ goes through all children again and gets bricks in proper order\n\tproto.reloadItems = function () {\n\t\t\/\/ collection of item elements\n\t\tthis.items = this._itemize(this.element.children);\n\t};\n\n\n\t\/**\n\t * turn elements into Outlayer.Items to be used in layout\n\t * @param {Array or NodeList or HTMLElement} elems\n\t * @returns {Array} items - collection of new Outlayer Items\n\t *\/\n\tproto._itemize = function (elems) {\n\n\t\tvar itemElems = this._filterFindItemElements(elems);\n\t\tvar Item = this.constructor.Item;\n\n\t\t\/\/ create new Outlayer Items for collection\n\t\tvar items = [];\n\t\tfor (var i = 0; i < itemElems.length; i++) {\n\t\t\tvar elem = itemElems[i];\n\t\t\tvar item = new Item(elem, this);\n\t\t\titems.push(item);\n\t\t}\n\n\t\treturn items;\n\t};\n\n\t\/**\n\t * get item elements to be used in layout\n\t * @param {Array or NodeList or HTMLElement} elems\n\t * @returns {Array} items - item elements\n\t *\/\n\tproto._filterFindItemElements = function (elems) {\n\t\treturn utils.filterFindElements(elems, this.options.itemSelector);\n\t};\n\n\t\/**\n\t * getter method for getting item elements\n\t * @returns {Array} elems - collection of item elements\n\t *\/\n\tproto.getItemElements = function () {\n\t\treturn this.items.map(function (item) {\n\t\t\treturn item.element;\n\t\t});\n\t};\n\n\/\/ ----- init & layout ----- \/\/\n\n\t\/**\n\t * lays out all items\n\t *\/\n\tproto.layout = function () {\n\t\tthis._resetLayout();\n\t\tthis._manageStamps();\n\n\t\t\/\/ don't animate first layout\n\t\tvar layoutInstant = this._getOption('layoutInstant');\n\t\tvar isInstant = layoutInstant !== undefined ?\n\t\t\tlayoutInstant : !this._isLayoutInited;\n\t\tthis.layoutItems(this.items, isInstant);\n\n\t\t\/\/ flag for initalized\n\t\tthis._isLayoutInited = true;\n\t};\n\n\/\/ _init is alias for layout\n\tproto._init = proto.layout;\n\n\t\/**\n\t * logic before any new layout\n\t *\/\n\tproto._resetLayout = function () {\n\t\tthis.getSize();\n\t};\n\n\n\tproto.getSize = function () {\n\t\tthis.size = getSize(this.element);\n\t};\n\n\t\/**\n\t * get measurement from option, for columnWidth, rowHeight, gutter\n\t * if option is String -> get element from selector string, & get size of element\n\t * if option is Element -> get size of element\n\t * else use option as a number\n\t *\n\t * @param {String} measurement\n\t * @param {String} size - width or height\n\t * @private\n\t *\/\n\tproto._getMeasurement = function (measurement, size) {\n\t\tvar option = this.options[measurement];\n\t\tvar elem;\n\t\tif (!option) {\n\t\t\t\/\/ default to 0\n\t\t\tthis[measurement] = 0;\n\t\t} else {\n\t\t\t\/\/ use option as an element\n\t\t\tif (typeof option == 'string') {\n\t\t\t\telem = this.element.querySelector(option);\n\t\t\t} else if (option instanceof HTMLElement) {\n\t\t\t\telem = option;\n\t\t\t}\n\t\t\t\/\/ use size of element, if element\n\t\t\tthis[measurement] = elem ? getSize(elem)[size] : option;\n\t\t}\n\t};\n\n\t\/**\n\t * layout a collection of item elements\n\t * @api public\n\t *\/\n\tproto.layoutItems = function (items, isInstant) {\n\t\titems = this._getItemsForLayout(items);\n\n\t\tthis._layoutItems(items, isInstant);\n\n\t\tthis._postLayout();\n\t};\n\n\t\/**\n\t * get the items to be laid out\n\t * you may want to skip over some items\n\t * @param {Array} items\n\t * @returns {Array} items\n\t *\/\n\tproto._getItemsForLayout = function (items) {\n\t\treturn items.filter(function (item) {\n\t\t\treturn !item.isIgnored;\n\t\t});\n\t};\n\n\t\/**\n\t * layout items\n\t * @param {Array} items\n\t * @param {Boolean} isInstant\n\t *\/\n\tproto._layoutItems = function (items, isInstant) {\n\t\tthis._emitCompleteOnItems('layout', items);\n\n\t\tif (!items || !items.length) {\n\t\t\t\/\/ no items, emit event with empty array\n\t\t\treturn;\n\t\t}\n\n\t\tvar queue = [];\n\n\t\titems.forEach(function (item) {\n\t\t\t\/\/ get x\/y object from method\n\t\t\tvar position = this._getItemLayoutPosition(item);\n\t\t\t\/\/ enqueue\n\t\t\tposition.item = item;\n\t\t\tposition.isInstant = isInstant || item.isLayoutInstant;\n\t\t\tqueue.push(position);\n\t\t}, this);\n\n\t\tthis._processLayoutQueue(queue);\n\t};\n\n\t\/**\n\t * get item layout position\n\t * @param {Outlayer.Item} item\n\t * @returns {Object} x and y position\n\t *\/\n\tproto._getItemLayoutPosition = function (\/* item *\/) {\n\t\treturn {\n\t\t\tx: 0,\n\t\t\ty: 0\n\t\t};\n\t};\n\n\t\/**\n\t * iterate over array and position each item\n\t * Reason being - separating this logic prevents 'layout invalidation'\n\t * thx @paul_irish\n\t * @param {Array} queue\n\t *\/\n\tproto._processLayoutQueue = function (queue) {\n\t\tthis.updateStagger();\n\t\tqueue.forEach(function (obj, i) {\n\t\t\tthis._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n\t\t}, this);\n\t};\n\n\/\/ set stagger from option in milliseconds number\n\tproto.updateStagger = function () {\n\t\tvar stagger = this.options.stagger;\n\t\tif (stagger === null || stagger === undefined) {\n\t\t\tthis.stagger = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.stagger = getMilliseconds(stagger);\n\t\treturn this.stagger;\n\t};\n\n\t\/**\n\t * Sets position of item in DOM\n\t * @param {Outlayer.Item} item\n\t * @param {Number} x - horizontal position\n\t * @param {Number} y - vertical position\n\t * @param {Boolean} isInstant - disables transitions\n\t *\/\n\tproto._positionItem = function (item, x, y, isInstant, i) {\n\t\tif (isInstant) {\n\t\t\t\/\/ if not transition, just set CSS\n\t\t\titem.goTo(x, y);\n\t\t} else {\n\t\t\titem.stagger(i * this.stagger);\n\t\t\titem.moveTo(x, y);\n\t\t}\n\t};\n\n\t\/**\n\t * Any logic you want to do after each layout,\n\t * i.e. size the container\n\t *\/\n\tproto._postLayout = function () {\n\t\tthis.resizeContainer();\n\t};\n\n\tproto.resizeContainer = function () {\n\t\tvar isResizingContainer = this._getOption('resizeContainer');\n\t\tif (!isResizingContainer) {\n\t\t\treturn;\n\t\t}\n\t\tvar size = this._getContainerSize();\n\t\tif (size) {\n\t\t\tthis._setContainerMeasure(size.width, true);\n\t\t\tthis._setContainerMeasure(size.height, false);\n\t\t}\n\t};\n\n\t\/**\n\t * Sets width or height of container if returned\n\t * @returns {Object} size\n\t *   @param {Number} width\n\t *   @param {Number} height\n\t *\/\n\tproto._getContainerSize = noop;\n\n\t\/**\n\t * @param {Number} measure - size of width or height\n\t * @param {Boolean} isWidth\n\t *\/\n\tproto._setContainerMeasure = function (measure, isWidth) {\n\t\tif (measure === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar elemSize = this.size;\n\t\t\/\/ add padding and border width if border box\n\t\tif (elemSize.isBorderBox) {\n\t\t\tmeasure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +\n\t\t\t\telemSize.borderLeftWidth + elemSize.borderRightWidth :\n\t\t\t\telemSize.paddingBottom + elemSize.paddingTop +\n\t\t\t\telemSize.borderTopWidth + elemSize.borderBottomWidth;\n\t\t}\n\n\t\tmeasure = Math.max(measure, 0);\n\t\tthis.element.style[isWidth ? 'width' : 'height'] = measure + 'px';\n\t};\n\n\t\/**\n\t * emit eventComplete on a collection of items events\n\t * @param {String} eventName\n\t * @param {Array} items - Outlayer.Items\n\t *\/\n\tproto._emitCompleteOnItems = function (eventName, items) {\n\t\tvar _this = this;\n\n\t\tfunction onComplete() {\n\t\t\t_this.dispatchEvent(eventName + 'Complete', null, [items]);\n\t\t}\n\n\t\tvar count = items.length;\n\t\tif (!items || !count) {\n\t\t\tonComplete();\n\t\t\treturn;\n\t\t}\n\n\t\tvar doneCount = 0;\n\n\t\tfunction tick() {\n\t\t\tdoneCount++;\n\t\t\tif (doneCount == count) {\n\t\t\t\tonComplete();\n\t\t\t}\n\t\t}\n\n\t\t\/\/ bind callback\n\t\titems.forEach(function (item) {\n\t\t\titem.once(eventName, tick);\n\t\t});\n\t};\n\n\t\/**\n\t * emits events via EvEmitter and jQuery events\n\t * @param {String} type - name of event\n\t * @param {Event} event - original event\n\t * @param {Array} args - extra arguments\n\t *\/\n\tproto.dispatchEvent = function (type, event, args) {\n\t\t\/\/ add original event to arguments\n\t\tvar emitArgs = event ? [event].concat(args) : args;\n\t\tthis.emitEvent(type, emitArgs);\n\n\t\tif (jQuery) {\n\t\t\t\/\/ set this.$element\n\t\t\tthis.$element = this.$element || jQuery(this.element);\n\t\t\tif (event) {\n\t\t\t\t\/\/ create jQuery event\n\t\t\t\tvar $event = jQuery.Event(event);\n\t\t\t\t$event.type = type;\n\t\t\t\tthis.$element.trigger($event, args);\n\t\t\t} else {\n\t\t\t\t\/\/ just trigger with type if no event available\n\t\t\t\tthis.$element.trigger(type, args);\n\t\t\t}\n\t\t}\n\t};\n\n\/\/ -------------------------- ignore & stamps -------------------------- \/\/\n\n\n\t\/**\n\t * keep item in collection, but do not lay it out\n\t * ignored items do not get skipped in layout\n\t * @param {Element} elem\n\t *\/\n\tproto.ignore = function (elem) {\n\t\tvar item = this.getItem(elem);\n\t\tif (item) {\n\t\t\titem.isIgnored = true;\n\t\t}\n\t};\n\n\t\/**\n\t * return item to layout collection\n\t * @param {Element} elem\n\t *\/\n\tproto.unignore = function (elem) {\n\t\tvar item = this.getItem(elem);\n\t\tif (item) {\n\t\t\tdelete item.isIgnored;\n\t\t}\n\t};\n\n\t\/**\n\t * adds elements to stamps\n\t * @param {NodeList, Array, Element, or String} elems\n\t *\/\n\tproto.stamp = function (elems) {\n\t\telems = this._find(elems);\n\t\tif (!elems) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.stamps = this.stamps.concat(elems);\n\t\t\/\/ ignore\n\t\telems.forEach(this.ignore, this);\n\t};\n\n\t\/**\n\t * removes elements to stamps\n\t * @param {NodeList, Array, or Element} elems\n\t *\/\n\tproto.unstamp = function (elems) {\n\t\telems = this._find(elems);\n\t\tif (!elems) {\n\t\t\treturn;\n\t\t}\n\n\t\telems.forEach(function (elem) {\n\t\t\t\/\/ filter out removed stamp elements\n\t\t\tutils.removeFrom(this.stamps, elem);\n\t\t\tthis.unignore(elem);\n\t\t}, this);\n\t};\n\n\t\/**\n\t * finds child elements\n\t * @param {NodeList, Array, Element, or String} elems\n\t * @returns {Array} elems\n\t *\/\n\tproto._find = function (elems) {\n\t\tif (!elems) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ if string, use argument as selector string\n\t\tif (typeof elems == 'string') {\n\t\t\telems = this.element.querySelectorAll(elems);\n\t\t}\n\t\telems = utils.makeArray(elems);\n\t\treturn elems;\n\t};\n\n\tproto._manageStamps = function () {\n\t\tif (!this.stamps || !this.stamps.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._getBoundingRect();\n\n\t\tthis.stamps.forEach(this._manageStamp, this);\n\t};\n\n\/\/ update boundingLeft \/ Top\n\tproto._getBoundingRect = function () {\n\t\t\/\/ get bounding rect for container element\n\t\tvar boundingRect = this.element.getBoundingClientRect();\n\t\tvar size = this.size;\n\t\tthis._boundingRect = {\n\t\t\tleft  : boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n\t\t\ttop   : boundingRect.top + size.paddingTop + size.borderTopWidth,\n\t\t\tright : boundingRect.right - (size.paddingRight + size.borderRightWidth),\n\t\t\tbottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n\t\t};\n\t};\n\n\t\/**\n\t * @param {Element} stamp\n\t **\/\n\tproto._manageStamp = noop;\n\n\t\/**\n\t * get x\/y position of element relative to container element\n\t * @param {Element} elem\n\t * @returns {Object} offset - has left, top, right, bottom\n\t *\/\n\tproto._getElementOffset = function (elem) {\n\t\tvar boundingRect = elem.getBoundingClientRect();\n\t\tvar thisRect = this._boundingRect;\n\t\tvar size = getSize(elem);\n\t\tvar offset = {\n\t\t\tleft  : boundingRect.left - thisRect.left - size.marginLeft,\n\t\t\ttop   : boundingRect.top - thisRect.top - size.marginTop,\n\t\t\tright : thisRect.right - boundingRect.right - size.marginRight,\n\t\t\tbottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n\t\t};\n\t\treturn offset;\n\t};\n\n\/\/ -------------------------- resize -------------------------- \/\/\n\n\/\/ enable event handlers for listeners\n\/\/ i.e. resize -> onresize\n\tproto.handleEvent = utils.handleEvent;\n\n\t\/**\n\t * Bind layout to window resizing\n\t *\/\n\tproto.bindResize = function () {\n\t\twindow.addEventListener('resize', this);\n\t\tthis.isResizeBound = true;\n\t};\n\n\t\/**\n\t * Unbind layout to window resizing\n\t *\/\n\tproto.unbindResize = function () {\n\t\twindow.removeEventListener('resize', this);\n\t\tthis.isResizeBound = false;\n\t};\n\n\tproto.onresize = function () {\n\t\tthis.resize();\n\t};\n\n\tutils.debounceMethod(Outlayer, 'onresize', 100);\n\n\tproto.resize = function () {\n\t\t\/\/ don't trigger if size did not change\n\t\t\/\/ or if resize was unbound. See #9\n\t\tif (!this.isResizeBound || !this.needsResizeLayout()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.layout();\n\t};\n\n\t\/**\n\t * check if layout is needed post layout\n\t * @returns Boolean\n\t *\/\n\tproto.needsResizeLayout = function () {\n\t\tvar size = getSize(this.element);\n\t\t\/\/ check that this.size and size are there\n\t\t\/\/ IE8 triggers resize on body size change, so they might not be\n\t\tvar hasSizes = this.size && size;\n\t\treturn hasSizes && size.innerWidth !== this.size.innerWidth;\n\t};\n\n\/\/ -------------------------- methods -------------------------- \/\/\n\n\t\/**\n\t * add items to Outlayer instance\n\t * @param {Array or NodeList or Element} elems\n\t * @returns {Array} items - Outlayer.Items\n\t **\/\n\tproto.addItems = function (elems) {\n\t\tvar items = this._itemize(elems);\n\t\t\/\/ add items to collection\n\t\tif (items.length) {\n\t\t\tthis.items = this.items.concat(items);\n\t\t}\n\t\treturn items;\n\t};\n\n\t\/**\n\t * Layout newly-appended item elements\n\t * @param {Array or NodeList or Element} elems\n\t *\/\n\tproto.appended = function (elems) {\n\t\tvar items = this.addItems(elems);\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ layout and reveal just the new items\n\t\tthis.layoutItems(items, true);\n\t\tthis.reveal(items);\n\t};\n\n\t\/**\n\t * Layout prepended elements\n\t * @param {Array or NodeList or Element} elems\n\t *\/\n\tproto.prepended = function (elems) {\n\t\tvar items = this._itemize(elems);\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ add items to beginning of collection\n\t\tvar previousItems = this.items.slice(0);\n\t\tthis.items = items.concat(previousItems);\n\t\t\/\/ start new layout\n\t\tthis._resetLayout();\n\t\tthis._manageStamps();\n\t\t\/\/ layout new stuff without transition\n\t\tthis.layoutItems(items, true);\n\t\tthis.reveal(items);\n\t\t\/\/ layout previous items\n\t\tthis.layoutItems(previousItems);\n\t};\n\n\t\/**\n\t * reveal a collection of items\n\t * @param {Array of Outlayer.Items} items\n\t *\/\n\tproto.reveal = function (items) {\n\t\tthis._emitCompleteOnItems('reveal', items);\n\t\tif (!items || !items.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar stagger = this.updateStagger();\n\t\titems.forEach(function (item, i) {\n\t\t\titem.stagger(i * stagger);\n\t\t\titem.reveal();\n\t\t});\n\t};\n\n\t\/**\n\t * hide a collection of items\n\t * @param {Array of Outlayer.Items} items\n\t *\/\n\tproto.hide = function (items) {\n\t\tthis._emitCompleteOnItems('hide', items);\n\t\tif (!items || !items.length) {\n\t\t\treturn;\n\t\t}\n\t\tvar stagger = this.updateStagger();\n\t\titems.forEach(function (item, i) {\n\t\t\titem.stagger(i * stagger);\n\t\t\titem.hide();\n\t\t});\n\t};\n\n\t\/**\n\t * reveal item elements\n\t * @param {Array}, {Element}, {NodeList} items\n\t *\/\n\tproto.revealItemElements = function (elems) {\n\t\tvar items = this.getItems(elems);\n\t\tthis.reveal(items);\n\t};\n\n\t\/**\n\t * hide item elements\n\t * @param {Array}, {Element}, {NodeList} items\n\t *\/\n\tproto.hideItemElements = function (elems) {\n\t\tvar items = this.getItems(elems);\n\t\tthis.hide(items);\n\t};\n\n\t\/**\n\t * get Outlayer.Item, given an Element\n\t * @param {Element} elem\n\t * @param {Function} callback\n\t * @returns {Outlayer.Item} item\n\t *\/\n\tproto.getItem = function (elem) {\n\t\t\/\/ loop through items to get the one that matches\n\t\tfor (var i = 0; i < this.items.length; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\tif (item.element == elem) {\n\t\t\t\t\/\/ return item\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t};\n\n\t\/**\n\t * get collection of Outlayer.Items, given Elements\n\t * @param {Array} elems\n\t * @returns {Array} items - Outlayer.Items\n\t *\/\n\tproto.getItems = function (elems) {\n\t\telems = utils.makeArray(elems);\n\t\tvar items = [];\n\t\telems.forEach(function (elem) {\n\t\t\tvar item = this.getItem(elem);\n\t\t\tif (item) {\n\t\t\t\titems.push(item);\n\t\t\t}\n\t\t}, this);\n\n\t\treturn items;\n\t};\n\n\t\/**\n\t * remove element(s) from instance and DOM\n\t * @param {Array or NodeList or Element} elems\n\t *\/\n\tproto.remove = function (elems) {\n\t\tvar removeItems = this.getItems(elems);\n\n\t\tthis._emitCompleteOnItems('remove', removeItems);\n\n\t\t\/\/ bail if no items to remove\n\t\tif (!removeItems || !removeItems.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveItems.forEach(function (item) {\n\t\t\titem.remove();\n\t\t\t\/\/ remove item from collection\n\t\t\tutils.removeFrom(this.items, item);\n\t\t}, this);\n\t};\n\n\/\/ ----- destroy ----- \/\/\n\n\/\/ remove and disable Outlayer instance\n\tproto.destroy = function () {\n\t\t\/\/ clean up dynamic styles\n\t\tvar style = this.element.style;\n\t\tstyle.height = '';\n\t\tstyle.position = '';\n\t\tstyle.width = '';\n\t\t\/\/ destroy items\n\t\tthis.items.forEach(function (item) {\n\t\t\titem.destroy();\n\t\t});\n\n\t\tthis.unbindResize();\n\n\t\tvar id = this.element.outlayerGUID;\n\t\tdelete instances[id]; \/\/ remove reference to instance by id\n\t\tdelete this.element.outlayerGUID;\n\t\t\/\/ remove data for jQuery\n\t\tif (jQuery) {\n\t\t\tjQuery.removeData(this.element, this.constructor.namespace);\n\t\t}\n\n\t};\n\n\/\/ -------------------------- data -------------------------- \/\/\n\n\t\/**\n\t * get Outlayer instance from element\n\t * @param {Element} elem\n\t * @returns {Outlayer}\n\t *\/\n\tOutlayer.data = function (elem) {\n\t\telem = utils.getQueryElement(elem);\n\t\tvar id = elem && elem.outlayerGUID;\n\t\treturn id && instances[id];\n\t};\n\n\n\/\/ -------------------------- create Outlayer class -------------------------- \/\/\n\n\t\/**\n\t * create a layout class\n\t * @param {String} namespace\n\t *\/\n\tOutlayer.create = function (namespace, options) {\n\t\t\/\/ sub-class Outlayer\n\t\tvar Layout = subclass(Outlayer);\n\t\t\/\/ apply new options and compatOptions\n\t\tLayout.defaults = utils.extend({}, Outlayer.defaults);\n\t\tutils.extend(Layout.defaults, options);\n\t\tLayout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n\n\t\tLayout.namespace = namespace;\n\n\t\tLayout.data = Outlayer.data;\n\n\t\t\/\/ sub-class Item\n\t\tLayout.Item = subclass(Item);\n\n\t\t\/\/ -------------------------- declarative -------------------------- \/\/\n\n\t\tutils.htmlInit(Layout, namespace);\n\n\t\t\/\/ -------------------------- jQuery bridge -------------------------- \/\/\n\n\t\t\/\/ make into jQuery plugin\n\t\tif (jQuery && jQuery.bridget) {\n\t\t\tjQuery.bridget(namespace, Layout);\n\t\t}\n\n\t\treturn Layout;\n\t};\n\n\tfunction subclass(Parent) {\n\t\tfunction SubClass() {\n\t\t\tParent.apply(this, arguments);\n\t\t}\n\n\t\tSubClass.prototype = Object.create(Parent.prototype);\n\t\tSubClass.prototype.constructor = SubClass;\n\n\t\treturn SubClass;\n\t}\n\n\/\/ ----- helpers ----- \/\/\n\n\/\/ how many milliseconds are in each unit\n\tvar msUnits = {\n\t\tms: 1,\n\t\ts : 1000\n\t};\n\n\/\/ munge time-like parameter into millisecond number\n\/\/ '0.4s' -> 40\n\tfunction getMilliseconds(time) {\n\t\tif (typeof time == 'number') {\n\t\t\treturn time;\n\t\t}\n\t\tvar matches = time.match(\/(^\\d*\\.?\\d*)(\\w*)\/);\n\t\tvar num = matches && matches[1];\n\t\tvar unit = matches && matches[2];\n\t\tif (!num.length) {\n\t\t\treturn 0;\n\t\t}\n\t\tnum = parseFloat(num);\n\t\tvar mult = msUnits[unit] || 1;\n\t\treturn num * mult;\n\t}\n\n\/\/ ----- fin ----- \/\/\n\n\/\/ back in global\n\tOutlayer.Item = Item;\n\n\treturn Outlayer;\n\n}));\n\n\/**\n * Isotope Item\n **\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('isotope-layout\/js\/item', [\n\t\t\t\t'outlayer\/outlayer'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('outlayer')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Isotope = window.Isotope || {};\n\t\twindow.Isotope.Item = factory(\n\t\t\twindow.Outlayer\n\t\t);\n\t}\n\n}(window, function factory(Outlayer) {\n\t'use strict';\n\n\/\/ -------------------------- Item -------------------------- \/\/\n\n\/\/ sub-class Outlayer Item\n\tfunction Item() {\n\t\tOutlayer.Item.apply(this, arguments);\n\t}\n\n\tvar proto = Item.prototype = Object.create(Outlayer.Item.prototype);\n\n\tvar _create = proto._create;\n\tproto._create = function () {\n\t\t\/\/ assign id, used for original-order sorting\n\t\tthis.id = this.layout.itemGUID++;\n\t\t_create.call(this);\n\t\tthis.sortData = {};\n\t};\n\n\tproto.updateSortData = function () {\n\t\tif (this.isIgnored) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ default sorters\n\t\tthis.sortData.id = this.id;\n\t\t\/\/ for backward compatibility\n\t\tthis.sortData['original-order'] = this.id;\n\t\tthis.sortData.random = Math.random();\n\t\t\/\/ go thru getSortData obj and apply the sorters\n\t\tvar getSortData = this.layout.options.getSortData;\n\t\tvar sorters = this.layout._sorters;\n\t\tfor (var key in getSortData) {\n\t\t\tvar sorter = sorters[key];\n\t\t\tthis.sortData[key] = sorter(this.element, this);\n\t\t}\n\t};\n\n\tvar _destroy = proto.destroy;\n\tproto.destroy = function () {\n\t\t\/\/ call super\n\t\t_destroy.apply(this, arguments);\n\t\t\/\/ reset display, #741\n\t\tthis.css({\n\t\t\tdisplay: ''\n\t\t});\n\t};\n\n\treturn Item;\n\n}));\n\n\/**\n * Isotope LayoutMode\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('isotope-layout\/js\/layout-mode', [\n\t\t\t\t'get-size\/get-size',\n\t\t\t\t'outlayer\/outlayer'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('get-size'),\n\t\t\trequire('outlayer')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Isotope = window.Isotope || {};\n\t\twindow.Isotope.LayoutMode = factory(\n\t\t\twindow.getSize,\n\t\t\twindow.Outlayer\n\t\t);\n\t}\n\n}(window, function factory(getSize, Outlayer) {\n\t'use strict';\n\n\t\/\/ layout mode class\n\tfunction LayoutMode(isotope) {\n\t\tthis.isotope = isotope;\n\t\t\/\/ link properties\n\t\tif (isotope) {\n\t\t\tthis.options = isotope.options[this.namespace];\n\t\t\tthis.element = isotope.element;\n\t\t\tthis.items = isotope.filteredItems;\n\t\t\tthis.size = isotope.size;\n\t\t}\n\t}\n\n\tvar proto = LayoutMode.prototype;\n\n\t\/**\n\t * some methods should just defer to default Outlayer method\n\t * and reference the Isotope instance as `this`\n\t **\/\n\tvar facadeMethods = [\n\t\t'_resetLayout',\n\t\t'_getItemLayoutPosition',\n\t\t'_manageStamp',\n\t\t'_getContainerSize',\n\t\t'_getElementOffset',\n\t\t'needsResizeLayout',\n\t\t'_getOption'\n\t];\n\n\tfacadeMethods.forEach(function (methodName) {\n\t\tproto[methodName] = function () {\n\t\t\treturn Outlayer.prototype[methodName].apply(this.isotope, arguments);\n\t\t};\n\t});\n\n\t\/\/ -----  ----- \/\/\n\n\t\/\/ for horizontal layout modes, check vertical size\n\tproto.needsVerticalResizeLayout = function () {\n\t\t\/\/ don't trigger if size did not change\n\t\tvar size = getSize(this.isotope.element);\n\t\t\/\/ check that this.size and size are there\n\t\t\/\/ IE8 triggers resize on body size change, so they might not be\n\t\tvar hasSizes = this.isotope.size && size;\n\t\treturn hasSizes && size.innerHeight != this.isotope.size.innerHeight;\n\t};\n\n\t\/\/ ----- measurements ----- \/\/\n\n\tproto._getMeasurement = function () {\n\t\tthis.isotope._getMeasurement.apply(this, arguments);\n\t};\n\n\tproto.getColumnWidth = function () {\n\t\tthis.getSegmentSize('column', 'Width');\n\t};\n\n\tproto.getRowHeight = function () {\n\t\tthis.getSegmentSize('row', 'Height');\n\t};\n\n\t\/**\n\t * get columnWidth or rowHeight\n\t * segment: 'column' or 'row'\n\t * size 'Width' or 'Height'\n\t **\/\n\tproto.getSegmentSize = function (segment, size) {\n\t\tvar segmentName = segment + size;\n\t\tvar outerSize = 'outer' + size;\n\t\t\/\/ columnWidth \/ outerWidth \/\/ rowHeight \/ outerHeight\n\t\tthis._getMeasurement(segmentName, outerSize);\n\t\t\/\/ got rowHeight or columnWidth, we can chill\n\t\tif (this[segmentName]) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ fall back to item of first element\n\t\tvar firstItemSize = this.getFirstItemSize();\n\t\tthis[segmentName] = firstItemSize && firstItemSize[outerSize] ||\n\t\t\t\/\/ or size of container\n\t\t\tthis.isotope.size['inner' + size];\n\t};\n\n\tproto.getFirstItemSize = function () {\n\t\tvar firstItem = this.isotope.filteredItems[0];\n\t\treturn firstItem && firstItem.element && getSize(firstItem.element);\n\t};\n\n\t\/\/ ----- methods that should reference isotope ----- \/\/\n\n\tproto.layout = function () {\n\t\tthis.isotope.layout.apply(this.isotope, arguments);\n\t};\n\n\tproto.getSize = function () {\n\t\tthis.isotope.getSize();\n\t\tthis.size = this.isotope.size;\n\t};\n\n\t\/\/ -------------------------- create -------------------------- \/\/\n\n\tLayoutMode.modes = {};\n\n\tLayoutMode.create = function (namespace, options) {\n\n\t\tfunction Mode() {\n\t\t\tLayoutMode.apply(this, arguments);\n\t\t}\n\n\t\tMode.prototype = Object.create(proto);\n\t\tMode.prototype.constructor = Mode;\n\n\t\t\/\/ default options\n\t\tif (options) {\n\t\t\tMode.options = options;\n\t\t}\n\n\t\tMode.prototype.namespace = namespace;\n\t\t\/\/ register in Isotope\n\t\tLayoutMode.modes[namespace] = Mode;\n\n\t\treturn Mode;\n\t};\n\n\treturn LayoutMode;\n\n}));\n\n\/*!\n * Masonry v4.2.1\n * Cascading grid layout library\n * http:\/\/masonry.desandro.com\n * MIT License\n * by David DeSandro\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('masonry-layout\/masonry', [\n\t\t\t\t'outlayer\/outlayer',\n\t\t\t\t'get-size\/get-size'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('outlayer'),\n\t\t\trequire('get-size')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Masonry = factory(\n\t\t\twindow.Outlayer,\n\t\t\twindow.getSize\n\t\t);\n\t}\n\n}(window, function factory(Outlayer, getSize) {\n\n\n\n\/\/ -------------------------- masonryDefinition -------------------------- \/\/\n\n\t\/\/ create an Outlayer layout class\n\tvar Masonry = Outlayer.create('masonry');\n\t\/\/ isFitWidth -> fitWidth\n\tMasonry.compatOptions.fitWidth = 'isFitWidth';\n\n\tvar proto = Masonry.prototype;\n\n\tproto._resetLayout = function () {\n\t\tthis.getSize();\n\t\tthis._getMeasurement('columnWidth', 'outerWidth');\n\t\tthis._getMeasurement('gutter', 'outerWidth');\n\t\tthis.measureColumns();\n\n\t\t\/\/ reset column Y\n\t\tthis.colYs = [];\n\t\tfor (var i = 0; i < this.cols; i++) {\n\t\t\tthis.colYs.push(0);\n\t\t}\n\n\t\tthis.maxY = 0;\n\t\tthis.horizontalColIndex = 0;\n\t};\n\n\tproto.measureColumns = function () {\n\t\tthis.getContainerWidth();\n\t\t\/\/ if columnWidth is 0, default to outerWidth of first item\n\t\tif (!this.columnWidth) {\n\t\t\tvar firstItem = this.items[0];\n\t\t\tvar firstItemElem = firstItem && firstItem.element;\n\t\t\t\/\/ columnWidth fall back to item of first element\n\t\t\tthis.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth ||\n\t\t\t\t\/\/ if first elem has no width, default to size of container\n\t\t\t\tthis.containerWidth;\n\t\t}\n\n\t\tvar columnWidth = this.columnWidth += this.gutter;\n\n\t\t\/\/ calculate columns\n\t\tvar containerWidth = this.containerWidth + this.gutter;\n\t\tvar cols = containerWidth \/ columnWidth;\n\t\t\/\/ fix rounding errors, typically with gutters\n\t\tvar excess = columnWidth - containerWidth % columnWidth;\n\t\t\/\/ if overshoot is less than a pixel, round up, otherwise floor it\n\t\tvar mathMethod = excess && excess < 1 ? 'round' : 'floor';\n\t\tcols = Math[mathMethod](cols);\n\t\tthis.cols = Math.max(cols, 1);\n\t};\n\n\tproto.getContainerWidth = function () {\n\t\t\/\/ container is parent if fit width\n\t\tvar isFitWidth = this._getOption('fitWidth');\n\t\tvar container = isFitWidth ? this.element.parentNode : this.element;\n\t\t\/\/ check that this.size and size are there\n\t\t\/\/ IE8 triggers resize on body size change, so they might not be\n\t\tvar size = getSize(container);\n\t\tthis.containerWidth = size && size.innerWidth;\n\t};\n\n\tproto._getItemLayoutPosition = function (item) {\n\t\titem.getSize();\n\t\t\/\/ how many columns does this brick span\n\t\tvar remainder = item.size.outerWidth % this.columnWidth;\n\t\tvar mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\n\t\t\/\/ round if off by 1 pixel, otherwise use ceil\n\t\tvar colSpan = Math[mathMethod](item.size.outerWidth \/ this.columnWidth);\n\t\tcolSpan = Math.min(colSpan, this.cols);\n\t\t\/\/ use horizontal or top column position\n\t\tvar colPosMethod = this.options.horizontalOrder ?\n\t\t\t'_getHorizontalColPosition' : '_getTopColPosition';\n\t\tvar colPosition = this[colPosMethod](colSpan, item);\n\t\t\/\/ position the brick\n\t\tvar position = {\n\t\t\tx: this.columnWidth * colPosition.col,\n\t\t\ty: colPosition.y\n\t\t};\n\t\t\/\/ apply setHeight to necessary columns\n\t\tvar setHeight = colPosition.y + item.size.outerHeight;\n\t\tvar setMax = colSpan + colPosition.col;\n\t\tfor (var i = colPosition.col; i < setMax; i++) {\n\t\t\tthis.colYs[i] = setHeight;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\tproto._getTopColPosition = function (colSpan) {\n\t\tvar colGroup = this._getTopColGroup(colSpan);\n\t\t\/\/ get the minimum Y value from the columns\n\t\tvar minimumY = Math.min.apply(Math, colGroup);\n\n\t\treturn {\n\t\t\tcol: colGroup.indexOf(minimumY),\n\t\t\ty  : minimumY,\n\t\t};\n\t};\n\n\t\/**\n\t * @param {Number} colSpan - number of columns the element spans\n\t * @returns {Array} colGroup\n\t *\/\n\tproto._getTopColGroup = function (colSpan) {\n\t\tif (colSpan < 2) {\n\t\t\t\/\/ if brick spans only one column, use all the column Ys\n\t\t\treturn this.colYs;\n\t\t}\n\n\t\tvar colGroup = [];\n\t\t\/\/ how many different places could this brick fit horizontally\n\t\tvar groupCount = this.cols + 1 - colSpan;\n\t\t\/\/ for each group potential horizontal position\n\t\tfor (var i = 0; i < groupCount; i++) {\n\t\t\tcolGroup[i] = this._getColGroupY(i, colSpan);\n\t\t}\n\t\treturn colGroup;\n\t};\n\n\tproto._getColGroupY = function (col, colSpan) {\n\t\tif (colSpan < 2) {\n\t\t\treturn this.colYs[col];\n\t\t}\n\t\t\/\/ make an array of colY values for that one group\n\t\tvar groupColYs = this.colYs.slice(col, col + colSpan);\n\t\t\/\/ and get the max value of the array\n\t\treturn Math.max.apply(Math, groupColYs);\n\t};\n\n\t\/\/ get column position based on horizontal index. #873\n\tproto._getHorizontalColPosition = function (colSpan, item) {\n\t\tvar col = this.horizontalColIndex % this.cols;\n\t\tvar isOver = colSpan > 1 && col + colSpan > this.cols;\n\t\t\/\/ shift to next row if item can't fit on current row\n\t\tcol = isOver ? 0 : col;\n\t\t\/\/ don't let zero-size items take up space\n\t\tvar hasSize = item.size.outerWidth && item.size.outerHeight;\n\t\tthis.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n\n\t\treturn {\n\t\t\tcol: col,\n\t\t\ty  : this._getColGroupY(col, colSpan),\n\t\t};\n\t};\n\n\tproto._manageStamp = function (stamp) {\n\t\tvar stampSize = getSize(stamp);\n\t\tvar offset = this._getElementOffset(stamp);\n\t\t\/\/ get the columns that this stamp affects\n\t\tvar isOriginLeft = this._getOption('originLeft');\n\t\tvar firstX = isOriginLeft ? offset.left : offset.right;\n\t\tvar lastX = firstX + stampSize.outerWidth;\n\t\tvar firstCol = Math.floor(firstX \/ this.columnWidth);\n\t\tfirstCol = Math.max(0, firstCol);\n\t\tvar lastCol = Math.floor(lastX \/ this.columnWidth);\n\t\t\/\/ lastCol should not go over if multiple of columnWidth #425\n\t\tlastCol -= lastX % this.columnWidth ? 0 : 1;\n\t\tlastCol = Math.min(this.cols - 1, lastCol);\n\t\t\/\/ set colYs to bottom of the stamp\n\n\t\tvar isOriginTop = this._getOption('originTop');\n\t\tvar stampMaxY = (isOriginTop ? offset.top : offset.bottom) +\n\t\t\tstampSize.outerHeight;\n\t\tfor (var i = firstCol; i <= lastCol; i++) {\n\t\t\tthis.colYs[i] = Math.max(stampMaxY, this.colYs[i]);\n\t\t}\n\t};\n\n\tproto._getContainerSize = function () {\n\t\tthis.maxY = Math.max.apply(Math, this.colYs);\n\t\tvar size = {\n\t\t\theight: this.maxY\n\t\t};\n\n\t\tif (this._getOption('fitWidth')) {\n\t\t\tsize.width = this._getContainerFitWidth();\n\t\t}\n\n\t\treturn size;\n\t};\n\n\tproto._getContainerFitWidth = function () {\n\t\tvar unusedCols = 0;\n\t\t\/\/ count unused columns\n\t\tvar i = this.cols;\n\t\twhile (--i) {\n\t\t\tif (this.colYs[i] !== 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tunusedCols++;\n\t\t}\n\t\t\/\/ fit container to columns that have been used\n\t\treturn (this.cols - unusedCols) * this.columnWidth - this.gutter;\n\t};\n\n\tproto.needsResizeLayout = function () {\n\t\tvar previousWidth = this.containerWidth;\n\t\tthis.getContainerWidth();\n\t\treturn previousWidth != this.containerWidth;\n\t};\n\n\treturn Masonry;\n\n}));\n\n\/*!\n * Masonry layout mode\n * sub-classes Masonry\n * http:\/\/masonry.desandro.com\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('isotope-layout\/js\/layout-modes\/masonry', [\n\t\t\t\t'..\/layout-mode',\n\t\t\t\t'masonry-layout\/masonry'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('..\/layout-mode'),\n\t\t\trequire('masonry-layout')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\tfactory(\n\t\t\twindow.Isotope.LayoutMode,\n\t\t\twindow.Masonry\n\t\t);\n\t}\n\n}(window, function factory(LayoutMode, Masonry) {\n\t'use strict';\n\n\/\/ -------------------------- masonryDefinition -------------------------- \/\/\n\n\t\/\/ create an Outlayer layout class\n\tvar MasonryMode = LayoutMode.create('masonry');\n\n\tvar proto = MasonryMode.prototype;\n\n\tvar keepModeMethods = {\n\t\t_getElementOffset: true,\n\t\tlayout           : true,\n\t\t_getMeasurement  : true\n\t};\n\n\t\/\/ inherit Masonry prototype\n\tfor (var method in Masonry.prototype) {\n\t\t\/\/ do not inherit mode methods\n\t\tif (!keepModeMethods[method]) {\n\t\t\tproto[method] = Masonry.prototype[method];\n\t\t}\n\t}\n\n\tvar measureColumns = proto.measureColumns;\n\tproto.measureColumns = function () {\n\t\t\/\/ set items, used if measuring first item\n\t\tthis.items = this.isotope.filteredItems;\n\t\tmeasureColumns.call(this);\n\t};\n\n\t\/\/ point to mode options for fitWidth\n\tvar _getOption = proto._getOption;\n\tproto._getOption = function (option) {\n\t\tif (option == 'fitWidth') {\n\t\t\treturn this.options.isFitWidth !== undefined ?\n\t\t\t\tthis.options.isFitWidth : this.options.fitWidth;\n\t\t}\n\t\treturn _getOption.apply(this.isotope, arguments);\n\t};\n\n\treturn MasonryMode;\n\n}));\n\n\/**\n * fitRows layout mode\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('isotope-layout\/js\/layout-modes\/fit-rows', [\n\t\t\t\t'..\/layout-mode'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof exports == 'object') {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('..\/layout-mode')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\tfactory(\n\t\t\twindow.Isotope.LayoutMode\n\t\t);\n\t}\n\n}(window, function factory(LayoutMode) {\n\t'use strict';\n\n\tvar FitRows = LayoutMode.create('fitRows');\n\n\tvar proto = FitRows.prototype;\n\n\tproto._resetLayout = function () {\n\t\tthis.x = 0;\n\t\tthis.y = 0;\n\t\tthis.maxY = 0;\n\t\tthis._getMeasurement('gutter', 'outerWidth');\n\t};\n\n\tproto._getItemLayoutPosition = function (item) {\n\t\titem.getSize();\n\n\t\tvar itemWidth = item.size.outerWidth + this.gutter;\n\t\t\/\/ if this element cannot fit in the current row\n\t\tvar containerWidth = this.isotope.size.innerWidth + this.gutter;\n\t\tif (this.x !== 0 && itemWidth + this.x > containerWidth) {\n\t\t\tthis.x = 0;\n\t\t\tthis.y = this.maxY;\n\t\t}\n\n\t\tvar position = {\n\t\t\tx: this.x,\n\t\t\ty: this.y\n\t\t};\n\n\t\tthis.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);\n\t\tthis.x += itemWidth;\n\n\t\treturn position;\n\t};\n\n\tproto._getContainerSize = function () {\n\t\treturn {height: this.maxY};\n\t};\n\n\treturn FitRows;\n\n}));\n\n\/**\n * vertical layout mode\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine('isotope-layout\/js\/layout-modes\/vertical', [\n\t\t\t\t'..\/layout-mode'\n\t\t\t],\n\t\t\tfactory);\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\trequire('..\/layout-mode')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\tfactory(\n\t\t\twindow.Isotope.LayoutMode\n\t\t);\n\t}\n\n}(window, function factory(LayoutMode) {\n\t'use strict';\n\n\tvar Vertical = LayoutMode.create('vertical', {\n\t\thorizontalAlignment: 0\n\t});\n\n\tvar proto = Vertical.prototype;\n\n\tproto._resetLayout = function () {\n\t\tthis.y = 0;\n\t};\n\n\tproto._getItemLayoutPosition = function (item) {\n\t\titem.getSize();\n\t\tvar x = (this.isotope.size.innerWidth - item.size.outerWidth) *\n\t\t\tthis.options.horizontalAlignment;\n\t\tvar y = this.y;\n\t\tthis.y += item.size.outerHeight;\n\t\treturn {x: x, y: y};\n\t};\n\n\tproto._getContainerSize = function () {\n\t\treturn {height: this.y};\n\t};\n\n\treturn Vertical;\n\n}));\n\n\/*!\n * Isotope v3.0.5\n *\n * Licensed GPLv3 for open source use\n * or Isotope Commercial License for commercial use\n *\n * http:\/\/isotope.metafizzy.co\n * Copyright 2017 Metafizzy\n *\/\n\n(function (window, factory) {\n\t\/\/ universal module definition\n\t\/* jshint strict: false *\/\n\t\/*globals define, module, require *\/\n\tif (typeof define == 'function' && define.amd) {\n\t\t\/\/ AMD\n\t\tdefine([\n\t\t\t\t'outlayer\/outlayer',\n\t\t\t\t'get-size\/get-size',\n\t\t\t\t'desandro-matches-selector\/matches-selector',\n\t\t\t\t'fizzy-ui-utils\/utils',\n\t\t\t\t'isotope-layout\/js\/item',\n\t\t\t\t'isotope-layout\/js\/layout-mode',\n\t\t\t\t\/\/ include default layout modes\n\t\t\t\t'isotope-layout\/js\/layout-modes\/masonry',\n\t\t\t\t'isotope-layout\/js\/layout-modes\/fit-rows',\n\t\t\t\t'isotope-layout\/js\/layout-modes\/vertical'\n\t\t\t],\n\t\t\tfunction (Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {\n\t\t\t\treturn factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);\n\t\t\t});\n\t} else if (typeof module == 'object' && module.exports) {\n\t\t\/\/ CommonJS\n\t\tmodule.exports = factory(\n\t\t\twindow,\n\t\t\trequire('outlayer'),\n\t\t\trequire('get-size'),\n\t\t\trequire('desandro-matches-selector'),\n\t\t\trequire('fizzy-ui-utils'),\n\t\t\trequire('isotope-layout\/js\/item'),\n\t\t\trequire('isotope-layout\/js\/layout-mode'),\n\t\t\t\/\/ include default layout modes\n\t\t\trequire('isotope-layout\/js\/layout-modes\/masonry'),\n\t\t\trequire('isotope-layout\/js\/layout-modes\/fit-rows'),\n\t\t\trequire('isotope-layout\/js\/layout-modes\/vertical')\n\t\t);\n\t} else {\n\t\t\/\/ browser global\n\t\twindow.Isotope = factory(\n\t\t\twindow,\n\t\t\twindow.Outlayer,\n\t\t\twindow.getSize,\n\t\t\twindow.matchesSelector,\n\t\t\twindow.fizzyUIUtils,\n\t\t\twindow.Isotope.Item,\n\t\t\twindow.Isotope.LayoutMode\n\t\t);\n\t}\n\n}(window, function factory(window, Outlayer, getSize, matchesSelector, utils,\n                           Item, LayoutMode) {\n\n\n\n\/\/ -------------------------- vars -------------------------- \/\/\n\n\tvar jQuery = window.jQuery;\n\n\/\/ -------------------------- helpers -------------------------- \/\/\n\n\tvar trim = String.prototype.trim ?\n\t\tfunction (str) {\n\t\t\treturn str.trim();\n\t\t} :\n\t\tfunction (str) {\n\t\t\treturn str.replace(\/^\\s+|\\s+$\/g, '');\n\t\t};\n\n\/\/ -------------------------- isotopeDefinition -------------------------- \/\/\n\n\t\/\/ create an Outlayer layout class\n\tvar Isotope = Outlayer.create('isotope', {\n\t\tlayoutMode       : 'masonry',\n\t\tisJQueryFiltering: true,\n\t\tsortAscending    : true\n\t});\n\n\tIsotope.Item = Item;\n\tIsotope.LayoutMode = LayoutMode;\n\n\tvar proto = Isotope.prototype;\n\n\tproto._create = function () {\n\t\tthis.itemGUID = 0;\n\t\t\/\/ functions that sort items\n\t\tthis._sorters = {};\n\t\tthis._getSorters();\n\t\t\/\/ call super\n\t\tOutlayer.prototype._create.call(this);\n\n\t\t\/\/ create layout modes\n\t\tthis.modes = {};\n\t\t\/\/ start filteredItems with all items\n\t\tthis.filteredItems = this.items;\n\t\t\/\/ keep of track of sortBys\n\t\tthis.sortHistory = ['original-order'];\n\t\t\/\/ create from registered layout modes\n\t\tfor (var name in LayoutMode.modes) {\n\t\t\tthis._initLayoutMode(name);\n\t\t}\n\t};\n\n\tproto.reloadItems = function () {\n\t\t\/\/ reset item ID counter\n\t\tthis.itemGUID = 0;\n\t\t\/\/ call super\n\t\tOutlayer.prototype.reloadItems.call(this);\n\t};\n\n\tproto._itemize = function () {\n\t\tvar items = Outlayer.prototype._itemize.apply(this, arguments);\n\t\t\/\/ assign ID for original-order\n\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\tvar item = items[i];\n\t\t\titem.id = this.itemGUID++;\n\t\t}\n\t\tthis._updateItemsSortData(items);\n\t\treturn items;\n\t};\n\n\n\t\/\/ -------------------------- layout -------------------------- \/\/\n\n\tproto._initLayoutMode = function (name) {\n\t\tvar Mode = LayoutMode.modes[name];\n\t\t\/\/ set mode options\n\t\t\/\/ HACK extend initial options, back-fill in default options\n\t\tvar initialOpts = this.options[name] || {};\n\t\tthis.options[name] = Mode.options ?\n\t\t\tutils.extend(Mode.options, initialOpts) : initialOpts;\n\t\t\/\/ init layout mode instance\n\t\tthis.modes[name] = new Mode(this);\n\t};\n\n\n\tproto.layout = function () {\n\t\t\/\/ if first time doing layout, do all magic\n\t\tif (!this._isLayoutInited && this._getOption('initLayout')) {\n\t\t\tthis.arrange();\n\t\t\treturn;\n\t\t}\n\t\tthis._layout();\n\t};\n\n\t\/\/ private method to be used in layout() & magic()\n\tproto._layout = function () {\n\t\t\/\/ don't animate first layout\n\t\tvar isInstant = this._getIsInstant();\n\t\t\/\/ layout flow\n\t\tthis._resetLayout();\n\t\tthis._manageStamps();\n\t\tthis.layoutItems(this.filteredItems, isInstant);\n\n\t\t\/\/ flag for initalized\n\t\tthis._isLayoutInited = true;\n\t};\n\n\t\/\/ filter + sort + layout\n\tproto.arrange = function (opts) {\n\t\t\/\/ set any options pass\n\t\tthis.option(opts);\n\t\tthis._getIsInstant();\n\t\t\/\/ filter, sort, and layout\n\n\t\t\/\/ filter\n\t\tvar filtered = this._filter(this.items);\n\t\tthis.filteredItems = filtered.matches;\n\n\t\tthis._bindArrangeComplete();\n\n\t\tif (this._isInstant) {\n\t\t\tthis._noTransition(this._hideReveal, [filtered]);\n\t\t} else {\n\t\t\tthis._hideReveal(filtered);\n\t\t}\n\n\t\tthis._sort();\n\t\tthis._layout();\n\t};\n\t\/\/ alias to _init for main plugin method\n\tproto._init = proto.arrange;\n\n\tproto._hideReveal = function (filtered) {\n\t\tthis.reveal(filtered.needReveal);\n\t\tthis.hide(filtered.needHide);\n\t};\n\n\t\/\/ HACK\n\t\/\/ Don't animate\/transition first layout\n\t\/\/ Or don't animate\/transition other layouts\n\tproto._getIsInstant = function () {\n\t\tvar isLayoutInstant = this._getOption('layoutInstant');\n\t\tvar isInstant = isLayoutInstant !== undefined ? isLayoutInstant :\n\t\t\t!this._isLayoutInited;\n\t\tthis._isInstant = isInstant;\n\t\treturn isInstant;\n\t};\n\n\t\/\/ listen for layoutComplete, hideComplete and revealComplete\n\t\/\/ to trigger arrangeComplete\n\tproto._bindArrangeComplete = function () {\n\t\t\/\/ listen for 3 events to trigger arrangeComplete\n\t\tvar isLayoutComplete, isHideComplete, isRevealComplete;\n\t\tvar _this = this;\n\n\t\tfunction arrangeParallelCallback() {\n\t\t\tif (isLayoutComplete && isHideComplete && isRevealComplete) {\n\t\t\t\t_this.dispatchEvent('arrangeComplete', null, [_this.filteredItems]);\n\t\t\t}\n\t\t}\n\n\t\tthis.once('layoutComplete', function () {\n\t\t\tisLayoutComplete = true;\n\t\t\tarrangeParallelCallback();\n\t\t});\n\t\tthis.once('hideComplete', function () {\n\t\t\tisHideComplete = true;\n\t\t\tarrangeParallelCallback();\n\t\t});\n\t\tthis.once('revealComplete', function () {\n\t\t\tisRevealComplete = true;\n\t\t\tarrangeParallelCallback();\n\t\t});\n\t};\n\n\t\/\/ -------------------------- filter -------------------------- \/\/\n\n\tproto._filter = function (items) {\n\t\tvar filter = this.options.filter;\n\t\tfilter = filter || '*';\n\t\tvar matches = [];\n\t\tvar hiddenMatched = [];\n\t\tvar visibleUnmatched = [];\n\n\t\tvar test = this._getFilterTest(filter);\n\n\t\t\/\/ test each item\n\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (item.isIgnored) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\/\/ add item to either matched or unmatched group\n\t\t\tvar isMatched = test(item);\n\t\t\t\/\/ item.isFilterMatched = isMatched;\n\t\t\t\/\/ add to matches if its a match\n\t\t\tif (isMatched) {\n\t\t\t\tmatches.push(item);\n\t\t\t}\n\t\t\t\/\/ add to additional group if item needs to be hidden or revealed\n\t\t\tif (isMatched && item.isHidden) {\n\t\t\t\thiddenMatched.push(item);\n\t\t\t} else if (!isMatched && !item.isHidden) {\n\t\t\t\tvisibleUnmatched.push(item);\n\t\t\t}\n\t\t}\n\n\t\t\/\/ return collections of items to be manipulated\n\t\treturn {\n\t\t\tmatches   : matches,\n\t\t\tneedReveal: hiddenMatched,\n\t\t\tneedHide  : visibleUnmatched\n\t\t};\n\t};\n\n\t\/\/ get a jQuery, function, or a matchesSelector test given the filter\n\tproto._getFilterTest = function (filter) {\n\t\tif (jQuery && this.options.isJQueryFiltering) {\n\t\t\t\/\/ use jQuery\n\t\t\treturn function (item) {\n\t\t\t\treturn jQuery(item.element).is(filter);\n\t\t\t};\n\t\t}\n\t\tif (typeof filter == 'function') {\n\t\t\t\/\/ use filter as function\n\t\t\treturn function (item) {\n\t\t\t\treturn filter(item.element);\n\t\t\t};\n\t\t}\n\t\t\/\/ default, use filter as selector string\n\t\treturn function (item) {\n\t\t\treturn matchesSelector(item.element, filter);\n\t\t};\n\t};\n\n\t\/\/ -------------------------- sorting -------------------------- \/\/\n\n\t\/**\n\t * @params {Array} elems\n\t * @public\n\t *\/\n\tproto.updateSortData = function (elems) {\n\t\t\/\/ get items\n\t\tvar items;\n\t\tif (elems) {\n\t\t\telems = utils.makeArray(elems);\n\t\t\titems = this.getItems(elems);\n\t\t} else {\n\t\t\t\/\/ update all items if no elems provided\n\t\t\titems = this.items;\n\t\t}\n\n\t\tthis._getSorters();\n\t\tthis._updateItemsSortData(items);\n\t};\n\n\tproto._getSorters = function () {\n\t\tvar getSortData = this.options.getSortData;\n\t\tfor (var key in getSortData) {\n\t\t\tvar sorter = getSortData[key];\n\t\t\tthis._sorters[key] = mungeSorter(sorter);\n\t\t}\n\t};\n\n\t\/**\n\t * @params {Array} items - of Isotope.Items\n\t * @private\n\t *\/\n\tproto._updateItemsSortData = function (items) {\n\t\t\/\/ do not update if no items\n\t\tvar len = items && items.length;\n\n\t\tfor (var i = 0; len && i < len; i++) {\n\t\t\tvar item = items[i];\n\t\t\titem.updateSortData();\n\t\t}\n\t};\n\n\t\/\/ ----- munge sorter ----- \/\/\n\n\t\/\/ encapsulate this, as we just need mungeSorter\n\t\/\/ other functions in here are just for munging\n\tvar mungeSorter = (function () {\n\t\t\/\/ add a magic layer to sorters for convienent shorthands\n\t\t\/\/ `.foo-bar` will use the text of .foo-bar querySelector\n\t\t\/\/ `[foo-bar]` will use attribute\n\t\t\/\/ you can also add parser\n\t\t\/\/ `.foo-bar parseInt` will parse that as a number\n\t\tfunction mungeSorter(sorter) {\n\t\t\t\/\/ if not a string, return function or whatever it is\n\t\t\tif (typeof sorter != 'string') {\n\t\t\t\treturn sorter;\n\t\t\t}\n\t\t\t\/\/ parse the sorter string\n\t\t\tvar args = trim(sorter).split(' ');\n\t\t\tvar query = args[0];\n\t\t\t\/\/ check if query looks like [an-attribute]\n\t\t\tvar attrMatch = query.match(\/^\\[(.+)\\]$\/);\n\t\t\tvar attr = attrMatch && attrMatch[1];\n\t\t\tvar getValue = getValueGetter(attr, query);\n\t\t\t\/\/ use second argument as a parser\n\t\t\tvar parser = Isotope.sortDataParsers[args[1]];\n\t\t\t\/\/ parse the value, if there was a parser\n\t\t\tsorter = parser ? function (elem) {\n\t\t\t\t\treturn elem && parser(getValue(elem));\n\t\t\t\t} :\n\t\t\t\t\/\/ otherwise just return value\n\t\t\t\tfunction (elem) {\n\t\t\t\t\treturn elem && getValue(elem);\n\t\t\t\t};\n\n\t\t\treturn sorter;\n\t\t}\n\n\t\t\/\/ get an attribute getter, or get text of the querySelector\n\t\tfunction getValueGetter(attr, query) {\n\t\t\t\/\/ if query looks like [foo-bar], get attribute\n\t\t\tif (attr) {\n\t\t\t\treturn function getAttribute(elem) {\n\t\t\t\t\treturn elem.getAttribute(attr);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t\/\/ otherwise, assume its a querySelector, and get its text\n\t\t\treturn function getChildText(elem) {\n\t\t\t\tvar child = elem.querySelector(query);\n\t\t\t\treturn child && child.textContent;\n\t\t\t};\n\t\t}\n\n\t\treturn mungeSorter;\n\t})();\n\n\t\/\/ parsers used in getSortData shortcut strings\n\tIsotope.sortDataParsers = {\n\t\t'parseInt'  : function (val) {\n\t\t\treturn parseInt(val, 10);\n\t\t},\n\t\t'parseFloat': function (val) {\n\t\t\treturn parseFloat(val);\n\t\t}\n\t};\n\n\t\/\/ ----- sort method ----- \/\/\n\n\t\/\/ sort filteredItem order\n\tproto._sort = function () {\n\t\tif (!this.options.sortBy) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ keep track of sortBy History\n\t\tvar sortBys = utils.makeArray(this.options.sortBy);\n\t\tif (!this._getIsSameSortBy(sortBys)) {\n\t\t\t\/\/ concat all sortBy and sortHistory, add to front, oldest goes in last\n\t\t\tthis.sortHistory = sortBys.concat(this.sortHistory);\n\t\t}\n\t\t\/\/ sort magic\n\t\tvar itemSorter = getItemSorter(this.sortHistory, this.options.sortAscending);\n\t\tthis.filteredItems.sort(itemSorter);\n\t};\n\n\t\/\/ check if sortBys is same as start of sortHistory\n\tproto._getIsSameSortBy = function (sortBys) {\n\t\tfor (var i = 0; i < sortBys.length; i++) {\n\t\t\tif (sortBys[i] != this.sortHistory[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t\/\/ returns a function used for sorting\n\tfunction getItemSorter(sortBys, sortAsc) {\n\t\treturn function sorter(itemA, itemB) {\n\t\t\t\/\/ cycle through all sortKeys\n\t\t\tfor (var i = 0; i < sortBys.length; i++) {\n\t\t\t\tvar sortBy = sortBys[i];\n\t\t\t\tvar a = itemA.sortData[sortBy];\n\t\t\t\tvar b = itemB.sortData[sortBy];\n\t\t\t\tif (a > b || a < b) {\n\t\t\t\t\t\/\/ if sortAsc is an object, use the value given the sortBy key\n\t\t\t\t\tvar isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;\n\t\t\t\t\tvar direction = isAscending ? 1 : -1;\n\t\t\t\t\treturn (a > b ? 1 : -1) * direction;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t}\n\n\t\/\/ -------------------------- methods -------------------------- \/\/\n\n\t\/\/ get layout mode\n\tproto._mode = function () {\n\t\tvar layoutMode = this.options.layoutMode;\n\t\tvar mode = this.modes[layoutMode];\n\t\tif (!mode) {\n\t\t\t\/\/ TODO console.error\n\t\t\tthrow new Error('No layout mode: ' + layoutMode);\n\t\t}\n\t\t\/\/ HACK sync mode's options\n\t\t\/\/ any options set after init for layout mode need to be synced\n\t\tmode.options = this.options[layoutMode];\n\t\treturn mode;\n\t};\n\n\tproto._resetLayout = function () {\n\t\t\/\/ trigger original reset layout\n\t\tOutlayer.prototype._resetLayout.call(this);\n\t\tthis._mode()._resetLayout();\n\t};\n\n\tproto._getItemLayoutPosition = function (item) {\n\t\treturn this._mode()._getItemLayoutPosition(item);\n\t};\n\n\tproto._manageStamp = function (stamp) {\n\t\tthis._mode()._manageStamp(stamp);\n\t};\n\n\tproto._getContainerSize = function () {\n\t\treturn this._mode()._getContainerSize();\n\t};\n\n\tproto.needsResizeLayout = function () {\n\t\treturn this._mode().needsResizeLayout();\n\t};\n\n\t\/\/ -------------------------- adding & removing -------------------------- \/\/\n\n\t\/\/ HEADS UP overwrites default Outlayer appended\n\tproto.appended = function (elems) {\n\t\tvar items = this.addItems(elems);\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ filter, layout, reveal new items\n\t\tvar filteredItems = this._filterRevealAdded(items);\n\t\t\/\/ add to filteredItems\n\t\tthis.filteredItems = this.filteredItems.concat(filteredItems);\n\t};\n\n\t\/\/ HEADS UP overwrites default Outlayer prepended\n\tproto.prepended = function (elems) {\n\t\tvar items = this._itemize(elems);\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ start new layout\n\t\tthis._resetLayout();\n\t\tthis._manageStamps();\n\t\t\/\/ filter, layout, reveal new items\n\t\tvar filteredItems = this._filterRevealAdded(items);\n\t\t\/\/ layout previous items\n\t\tthis.layoutItems(this.filteredItems);\n\t\t\/\/ add to items and filteredItems\n\t\tthis.filteredItems = filteredItems.concat(this.filteredItems);\n\t\tthis.items = items.concat(this.items);\n\t};\n\n\tproto._filterRevealAdded = function (items) {\n\t\tvar filtered = this._filter(items);\n\t\tthis.hide(filtered.needHide);\n\t\t\/\/ reveal all new items\n\t\tthis.reveal(filtered.matches);\n\t\t\/\/ layout new items, no transition\n\t\tthis.layoutItems(filtered.matches, true);\n\t\treturn filtered.matches;\n\t};\n\n\t\/**\n\t * Filter, sort, and layout newly-appended item elements\n\t * @param {Array or NodeList or Element} elems\n\t *\/\n\tproto.insert = function (elems) {\n\t\tvar items = this.addItems(elems);\n\t\tif (!items.length) {\n\t\t\treturn;\n\t\t}\n\t\t\/\/ append item elements\n\t\tvar i, item;\n\t\tvar len = items.length;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\titem = items[i];\n\t\t\tthis.element.appendChild(item.element);\n\t\t}\n\t\t\/\/ filter new stuff\n\t\tvar filteredInsertItems = this._filter(items).matches;\n\t\t\/\/ set flag\n\t\tfor (i = 0; i < len; i++) {\n\t\t\titems[i].isLayoutInstant = true;\n\t\t}\n\t\tthis.arrange();\n\t\t\/\/ reset flag\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tdelete items[i].isLayoutInstant;\n\t\t}\n\t\tthis.reveal(filteredInsertItems);\n\t};\n\n\tvar _remove = proto.remove;\n\tproto.remove = function (elems) {\n\t\telems = utils.makeArray(elems);\n\t\tvar removeItems = this.getItems(elems);\n\t\t\/\/ do regular thing\n\t\t_remove.call(this, elems);\n\t\t\/\/ bail if no items to remove\n\t\tvar len = removeItems && removeItems.length;\n\t\t\/\/ remove elems from filteredItems\n\t\tfor (var i = 0; len && i < len; i++) {\n\t\t\tvar item = removeItems[i];\n\t\t\t\/\/ remove item from collection\n\t\t\tutils.removeFrom(this.filteredItems, item);\n\t\t}\n\t};\n\n\tproto.shuffle = function () {\n\t\t\/\/ update random sortData\n\t\tfor (var i = 0; i < this.items.length; i++) {\n\t\t\tvar item = this.items[i];\n\t\t\titem.sortData.random = Math.random();\n\t\t}\n\t\tthis.options.sortBy = 'random';\n\t\tthis._sort();\n\t\tthis._layout();\n\t};\n\n\t\/**\n\t * trigger fn without transition\n\t * kind of hacky to have this in the first place\n\t * @param {Function} fn\n\t * @param {Array} args\n\t * @returns ret\n\t * @private\n\t *\/\n\tproto._noTransition = function (fn, args) {\n\t\t\/\/ save transitionDuration before disabling\n\t\tvar transitionDuration = this.options.transitionDuration;\n\t\t\/\/ disable transition\n\t\tthis.options.transitionDuration = 0;\n\t\t\/\/ do it\n\t\tvar returnValue = fn.apply(this, args);\n\t\t\/\/ re-enable transition for reveal\n\t\tthis.options.transitionDuration = transitionDuration;\n\t\treturn returnValue;\n\t};\n\n\t\/\/ ----- helper methods ----- \/\/\n\n\t\/**\n\t * getter method for getting filtered item elements\n\t * @returns {Array} elems - collection of item elements\n\t *\/\n\tproto.getFilteredItemElements = function () {\n\t\treturn this.filteredItems.map(function (item) {\n\t\t\treturn item.element;\n\t\t});\n\t};\n\n\t\/\/ -----  ----- \/\/\n\n\treturn Isotope;\n\n}));\r\n","status":true}